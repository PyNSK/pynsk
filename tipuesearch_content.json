{"pages":[{"text":"PyNSK - первое Python сообщество в городе Новосибирск Сообщество имеет как онлайн и оффлайн составляющую: Оффлайн Мы встречаемся раз в месяц. На встречах слушаем доклады и много обсуждаем Python. Онлайн Группа в ВКонтакте - http://vk.com/pynsk - это основная группа сообщества, где публикуются свежие новости и посты Этот сайт - http://pynsk.ru/ - на нем публикуется архив статей сообщества, ссылки на доклады. Чат - https://gitter.im/PyNSK/PyNSK - чат, где мы общаемся","tags":"pages","title":"О сообществе","url":"http://pynsk.ru/pages/about.html"},{"text":"Таинство стандартной библиотеки: модуль operator Модуль operator содержит набор функций, соответствующих операторам Python. Вот некоторые функции: operator . add ( a , b ) # суммирует два значения operator . ne ( a , b ) # то же, что и a!=b operator . attrgetter ( 'id' ) # возвращает ссылку, по которой можно получить атрибут \"id\" Казалось бы, зачем нужны они? А ответ довольно прост - функциональное программирование с использованием итераторов иногда требует создания небольших функций для простых выражений. Иногда они могут быть выражены как лямбда-функции, но некоторые операции не обязательно реализовывать самостоятельно: Код для Python 2: >>> import operator >>> a = [ 2 , 3 , 4 , 5 ] >>> reduce ( lambda x , y : x + y , a ) 14 >>> reduce ( operator . add , a ) 14 Ссылки для изучения: https://pymotw.com/2/operator/ https://docs.python.org/3.5/library/operator.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: модуль operator","url":"http://pynsk.ru/posts/2015/сент./20/tainstvo-standartnoi-biblioteki-modul-operator/"},{"text":"Идеи функционального программирования довольно популярны, в том числе и в среде программистов на Python, который не является функциональным языком. В докладе речь пойдёт об особенностях функционального стиля в Python, об его отличиях от типичных функциональных языков типа Haskell.","tags":"Функциональный Python","title":"Функциональный Python: Python — это не Haskell","url":"http://pynsk.ru/posts/2015/сент./19/funktsionalnyi-python-python-eto-ne-haskell/"},{"text":"Python имеет автоматическое управление памятью: подсчёт ссылок для большинства объектов и сборка мусора для удаления циклов. Память освобождается сразу после того, как была удалена последняя ссылка на объект. Этот подход отлично работает для большинства приложений, но иногда возникает необходимость вести учёт объектов только когда они используются где-нибудь ещё. К сожалению, само слежение за объектами уже создает ссылку и тем самым объекты остаются в памяти. Модуль weakref (от англ. weak reference - слабая ссылка) даёт средство для учёта объектов без создания ссылок на них. Когда объект больше не нужен, он автоматически удаляется из таблицы слабых ссылок и производится обратный вызов weakref-объектов. Типичное применение модуля - кэширование объектов, которые затратно воспроизвести снова. >>> import weakref , gc >>> class A : ... def __init__ ( self , value ): ... self . value = value ... def __repr__ ( self ): ... return str ( self . value ) ... >>> a = A ( 10 ) # создаёт ссылку >>> d = weakref . WeakValueDictionary () # словарь, использующий слабые ссылки >>> d [ 'primary' ] = a # не создаёт ссылки >>> d [ 'primary' ] # достать объект, если он все ещё \"жив\" 10 >>> del a # удалить одну ссылку >>> gc . collect () # произвести сборку мусора 0 >>> d [ 'primary' ] # запись была автоматически удалена Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > d [ 'primary' ] File \"C:/python31/lib/weakref.py\" , line 46 , in __getitem__ o = self . data [ key ]() KeyError : 'primary' Ссылки на тему: https://docs.python.org/3/library/weakref.html http://pep8.ru/doc/tutorial-3.1/11.html http://www.ilnurgi1.ru/docs/python/modules/weakref.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: слабые ссылки - weakref","url":"http://pynsk.ru/posts/2015/сент./19/tainstvo-standartnoi-biblioteki-slabye-ssylki-weakref/"},{"text":"Любая программа использует импорт модулей. Но, как показал беглый опрос, далеко не все программисты представляют, как работает импорт, что содержится в модуле и как этот импорт можно расширять для своих нужд. Удивительный факт: даже англоязычные ресурсы предоставляют недостаточно информации Серия статей: http://asvetlov.blogspot.ru/2010/05/blog-post.html http://asvetlov.blogspot.ru/2010/05/2.html http://asvetlov.blogspot.ru/2010/05/3.html","tags":"Внутренности Python","title":"Внутренности Python: импорт в Питоне","url":"http://pynsk.ru/posts/2015/сент./17/vnutrennosti-python-import-v-pitone/"},{"text":"Gensim - библиотека Python для моделирования, тематическое моделирование документов и извлечения подобия с больших корпусов. Целевая аудитория является обработка естественного языка (НЛП) и IR сообщество. В Gensim реализованы популярные алгоритмы НЛП. Например, word2vec. Большинство реализаций алгоритмов умеет использовать несколько ядер. https://github.com/piskvorky/gensim/","tags":"Полезные библиотеки","title":"Полезные библиотеки: gensim - библиотека для моделирования над текстами","url":"http://pynsk.ru/posts/2015/сент./17/poleznye-biblioteki-gensim-biblioteka-dlia-modelirovaniia-nad-tekstami/"},{"text":"Интерфейс администратора Django достается разработчику \"даром\" - прописываешь немного срочек и готово. Появляется UI где можно изменять объекты моделей - просто так нам предоставляют GRUD возможности. Но что если нам надо сделать какие-то дополнительные возможности? Для примера такие действия есть в Python Дайджест: Такие возможности реализуются с помощью Django admin actions. Для примера так: class ItemModeratorAdmin ( admin . ModelAdmin ): actions = [ '_action_make_moderated' , ] def _action_set_queue ( self , request , queryset ): queryset . update ( status = 'queue' ) _action_set_queue . short_description = 'В очередь' Можно заметить, что добавлена функция, которая принимает request и queryset. queryset - в данном случае это набор выделенных объектов (у тех что галочки стоят). Подробная информация по ссылке: https://docs.djangoproject.com/en/1.8/ref/contrib/admin/actions/","tags":"Пишем web-проекты","title":"Пишем web-проекты: Django Admin Actions","url":"http://pynsk.ru/posts/2015/сент./16/pishem-web-proekty-django-admin-actions/"},{"text":"","tags":"Опыт разработчиков","title":"Опыт разработчиков: Работа с ошибками. Как ловить исключения и что потом с ними делать","url":"http://pynsk.ru/posts/2015/сент./15/opyt-razrabotchikov-rabota-s-oshibkami-kak-lovit-iskliucheniia-i-chto-potom-s-nimi-delat/"},{"text":"Опыт разработчиков: assert как средство для валидации Хочется сегодня осветить такой элемент синтаксиса как assert. assert - это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Какая же польза от этой проверки? Представим что мы что-то пишем код, который получает данные из Базы Данных, производит обработку данных и загружает результат обратно. По замыслу этого кода мы должны положить в базу столько же данных сколько и получили. Но так как мы написали код с ошибками (случайно), то количество данных не совпадает. И что же случится? В этом случае очень хорошо себя показывает assert. Эта конструкция проверят данные и в случае не соответствия ожиданиям - бросает AssertException. Примеры кода: assert 'command' in data , 'Not found command' assert data . get ( 'command' ) == command , 'Not valid command'","tags":"Опыт разработчиков","title":"Опыт разработчиков: assert как средство для валидации","url":"http://pynsk.ru/posts/2015/сент./15/opyt-razrabotchikov-assert-kak-sredstvo-dlia-validatsii/"},{"text":"Матрица - это, если утрировать, \"табличка\", N-мерный массив (чаще всего двумерный). Матрицы возникают не редко. Например, игровое поле, карта мира - тоже можно представить матрицей, да то же решето Эратосфена - тоже двумерный массив, или вообще - вложенные списки. Это все создает необходимость знать как работать с матрицами и какими инструментами. Модулей для работы с этими объектами не мало, самые известные - стандартный math и numpy. В Python 3.5 появился новый оператор - @ Этот оператор позволяет перемножать матрицы: a @ b Подробно о операторе: https://www.python.org/dev/peps/pep-0465/","tags":"Синтаксис Python","title":"Синтаксис Python: работа с матрицами","url":"http://pynsk.ru/posts/2015/сент./14/sintaksis-python-rabota-s-matritsami/"},{"text":"Учебные материалы: книга \"Программируем коллективный разум\" Книга \"Программируем коллективный разум\" - это введение в мир машинного обучения и статистики. В ней объясняется, как делать полезные с точки зрения маркетинга выводы о поведении и предпочтениях пользователей на основе информации, ежедневно собираемой вашими и сторонними приложениями. Каждый алгоритм описан четко и кратко и сопровождается кодом, который можно сразу же включить в собственный сайт, блог, Вики или какое-нибудь специализированное приложение. Прелесть этой книги в том, что все примеры на Python. Конечно, код там не фонтан - но он есть.","tags":"Учебные материалы","title":"Учебные материалы: книга \"Программируем коллективный разум\"","url":"http://pynsk.ru/posts/2015/сент./14/uchebnye-materialy-kniga-programmiruem-kollektivnyi-razum/"},{"text":"Таинство стандартной библиотеки: textwrap для укорочения текстов При работе над Python Дайджестом - http://pythondigest.ru/ а именно при работе над \"Колонкой автора\" возникла такая задачка - уменьшить длину описания. Описание ссылок берется из RSS этой группы и оно иногда длинное. Как же наиболее просто решить эту задачу? Самое простое - взять строку описания и взять, скажем первые 300 символов. Просто? Только вот проблема - слово может оборваться на середине. Чтобы не обрабатывать эту ситуацию самостоятельно, можно воспользоваться модулем textwrap. textwrap это стандартный модуль, который позволяет всячески укорачивать текст. Например, можно ограничить длину строки (будет текст выводится в несколько строк). Озвученную задачу можно решить так: import textwrap content = textwrap . shorten ( raw_content , width = 300 ) Ссылки на тему: http://www.dotnetperls.com/textwrap https://docs.python.org/3.5/library/textwrap.html https://pymotw.com/2/textwrap/","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: textwrap для сокращения текста","url":"http://pynsk.ru/posts/2015/сент./13/tainstvo-standartnoi-biblioteki-textwrap-dlia-sokrashcheniia-teksta/"},{"text":"Вы знаете что такое super()? Думаете что это вызов метода класса родителя? Если так, то вам стоит посмотреть это видео.","tags":"Синтаксис Python","title":"Синтаксис Python: super() это супер","url":"http://pynsk.ru/posts/2015/сент./11/sintaksis-python-super-eto-super/"},{"text":"","tags":"Hardcore Python","title":"Hardcore Python: Конкурентность в Питоне с нуля. Вживую","url":"http://pynsk.ru/posts/2015/сент./10/hardcore-python-konkurentnost-v-pitone-s-nulia-vzhivuiu/"},{"text":"Полезные библиотеки: funcy - набор конструкций, которые упрощают код Есть ряд модулей, которые стоит ставить первыми. Этот набор у каждого свой. В моем наборе есть место для funcy. funcy - это набор мелких полезностей при работе с данными. Например, можно создать бесконечный список, объединить список списков, объединение словарей, можно превращать вложенные структуры в плоские и наоборот. Это не весь список возможностей - а он и вправду огромный. Посмотрите хотя бы README - https://github.com/Suor/funcy http://habrahabr.ru/post/174619/ P.S. funcy - написана разработчиком из Красноярска","tags":"Полезные библиотеки","title":"Полезные библиотеки: funcy - набор конструкций, которые упрощают код","url":"http://pynsk.ru/posts/2015/сент./09/poleznye-biblioteki-funcy-nabor-konstruktsii-kotorye-uproshchaiut-kod/"},{"text":"Порой возникают рутинные задачи, которые не хочется делать руками. Примером такой задачи может являться - скачать множество страниц по ссылкам. Если 5 ссылок еще вручную сохранить можно, а если их 1000? или 6250, как было в моем случае. На Python эту задачу можно с помощью модуля asyncio и aiohttp. Вот такой код можно написать за пару минут: import asyncio import aiohttp @asyncio.coroutine def download ( url ): try : response = yield from aiohttp . request ( 'GET' , url ) data = yield from response . text () yield from save_page ( url , data ) # сохраняем страницу в файл, или еще куда except Exception as e : return None @asyncio.coroutine def download_parallel ( urls ): tasks = [ asyncio . Task ( download ( url )) for url in urls ] yield from asyncio . gather ( * tasks ) urls = [ < список ссылок > ] # список ссылок loop = asyncio . get_event_loop () loop . run_until_complete ( download_parallel ( urls ))","tags":"Извлечение информации","title":"Извлечение информации: скачиваем список ссылок с помощью asyncio","url":"http://pynsk.ru/posts/2015/сент./09/izvlechenie-informatsii-skachivaem-spisok-ssylok-s-pomoshchiu-asyncio/"},{"text":"Тесты тесты тесты: coverage - узнаем сколько процентов кода покрыто тестами Юнит-тесты хороши, когда покрывают весь ключевой код. Однако если проект чуть больше, чем \"Hello, world!\", то оценить степень покрытия весьма проблематично. Существуют инструменты, которые помогают это делать. Например - coverage.py - модуль Неда Бачелдера. coverage.py - написан на основе стандартной библлиотеки, может использоваться как из командной строки, так и из кода (как библиотека). Плюс к этому, он может выдавать как суммарный результат (в процентах), так и анотированный (т.е. копия исходного файла, в котором протестированная строка помечается >, не протестированная - !). https://github.com/nedbat/coveragepy","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: coverage - узнаем сколько процентов кода покрыто тестами","url":"http://pynsk.ru/posts/2015/сент./08/testy-testy-testy-coverage-uznaem-skolko-protsentov-koda-pokryto-testami/"},{"text":"Генераторы это итерируемые объекты, которые можно прочитать лишь один раз. Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету: >>> mygenerator = (x*x for x in range(3)) >>> for i in mygenerator : ... print(i) 0 1 4 Казалось бы, всего один раз можно пройти по данным. Зачем это? На практике мы редко проходим по одним и тем же данным несколько раз. При этом нам не всегда нужны все данные. Например, стоит задача проверить что все элементы массива положительные. Вот мы пишем цикл, в котором сравниваем элементы с нулем. И бац, попадается отрицательный элемент. Можем уже дальше не проверять и уже кинуть ошибку. При этом весь массив не находится в памяти. Это если обычные числа, а если элементы коллекции это результаты вычисления функции - вот как в коде выше, это квадраты. А элементов у нас не 3, а 1 миллион. А в данный момент нам нужны только первые 500, по ним определим нужны ли нам остальные. Вот здесь и приходят на помощь генераторы - они возвращают именно столько сколько и надо данных.","tags":"Синтаксис Python","title":"Синтаксис Python: генераторы","url":"http://pynsk.ru/posts/2015/сент./07/sintaksis-python-generatory/"},{"text":"Не так редко спрашивают \"Какую книжку почитать\". Ответить на такой вопрос не просто, ибо зависит от человека. Однако, есть и универсальные книги - справочники. Сегодня хочу представить аннотацию к книге - Python. Подробный справочник от Дэвида Бизли. «Python. Подробный справочник» — это авторитетное руководство и детальный путеводитель по языку программирования Python. Книга предназначена для практикующих программистов; она нацелена на суть дела и написана очень доступным языком. Она детально описывает не только ядро языка, но и наиболее важные части стандартной библиотеки Python. Дополнительно освещается ряд тем, которые не рассматриваются ни в официальной документации, ни в каких-либо других источниках. Читателю предлагается практическое знакомство с особенностями Python, включая генераторы, сопрограммы, замыкания, метаклассы и декораторы. Подробно описаны новые модули, имеющие отношение к разработке многозадачных программ, использующих потоки управления и дочерние процессы, а также предназначенные для работы с системными службами и организации сетевых взаимодействий.","tags":"Учебные материалы","title":"Учебные материалы: Python. Подробный справочник","url":"http://pynsk.ru/posts/2015/сент./07/uchebnye-materialy-python-podrobnyi-spravochnik/"},{"text":"Еще один стандартный модуль в Python - itertools. Модуль itertools - сборник полезных итераторов. В нем содержатся множество операций над итераторами, да и сами интераторы. Например есть бесконечная арифметическая прогрессия, можно объединять, разъединять итераторы, всячески извлекать значения как из одного так и групп итераторов, повторять итератор, группировать значения итератора и многое другое. А что именно - по ссылкам. Ссылки по теме: https://docs.python.org/3.5/library/itertools.html https://pymotw.com/2/itertools/ http://pythonworld.ru/moduli/modul-itertools.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: itertools","url":"http://pynsk.ru/posts/2015/сент./06/tainstvo-standartnoi-biblioteki-itertools/"},{"text":"Docstring - (сокращение от documentation string, строка документации) встроенное средство документирования модулей, функций, классов и методов. Делается очень просто - сразу после определения указывается строковое значение, которое и будет docstring'ом. >>> def test (): ... \"This is the test's docstring\" ... print \"opa\" Получить доступ к docstring можно так: >>> test . __doc__ \"This is the test's docstring\" Либо так: >>> help ( test ) Help on function test in module __main__ : test () This is the test 's docstring Существуют инструменты, которые позволяют извлекать docstring не по одиночке, а для целого модуля/пакета. О них и пойдет речь. Изучаем дальше: https://www.python.org/dev/peps/pep-0257/ http://pyobject.ru/blog/2006/09/08/document-it/ http://habrahabr.ru/post/149371/","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: docstring","url":"http://pynsk.ru/posts/2015/сент./06/tainstvo-standartnoi-biblioteki-docstring/"},{"text":"PySide — привязка языка Python к инструментарию Qt, совместимая на уровне API с PyQt. В отличие от PyQt, PySide доступна для свободного использования как в открытых, так и закрытых, в частности, коммерческих проектах, поскольку лицензирована по LGPL. Проект возник в результате нежелания создателей PyQt менять лицензионную политику для своего проекта. Свет PySide увидел в августе 2009 года, когда была выпущена первая публичная версия. Основными разработчиками PySide являются программисты Digia.","tags":"Полезные модули","title":"Полезные модули: PySide","url":"http://pynsk.ru/posts/2015/сент./05/poleznye-moduli-pyside/"},{"text":"Проекты все чаще зарождаются именно в web, однако, и десктоп ПО еще живо, да и инструментарий к нему. В частности, кроссплатформенный фреймворк Qt имеет обертку для Python - PyQt. Уже давно все крупные GUI-фреймворки имеют дизайнер форм (в нашем случае - Qt designer). В которой вы можете набросать мышкой кнопки на формы, а уже затем в коде добавить логику работы с ними. Соединение логики и GUI в PyQt можно делать двумя способами - .ui файл (такой файл выдает дизайнер форм) конвертировать в py файл и отнаследоваться от класса. Понятно, что если идет активная разработка GUI, то придется множество раз конвертировать, что лень. Поэтому есть более простое решение - напрямую подключать .ui файл. Для этого есть методы loadUi и loadUiType","tags":"Полезные модули","title":"Полезные модули: PyQt","url":"http://pynsk.ru/posts/2015/сент./05/poleznye-moduli-pyqt/"},{"text":"Первой проблемой при поддержке старых проектов является понять, как запустить его. Чтобы немного упростить эту задачу разработчики используют pip и файл requirements.txt. В этом файле записываются все необходимые для работы библиотеки и, что самое главное, указывают версии этих библиотек. Имея такой файл настройка окружения для старта проекта может состоять из одной команды: pip install -r requirements.txt","tags":"Опыт разработчиков","title":"Опыт разработчиков: файл requirements.txt в каждый проект","url":"http://pynsk.ru/posts/2015/сент./04/opyt-razrabotchikov-fail-requirementstxt-v-kazhdyi-proekt/"},{"text":"Postgres предоставляет много встроенных возможностей для создания эфективных приложений, использующих базы данных. А в версии 9.4 появляется еще и полноценное JSON поле, при правильном использовании которого, отпадает необходимость использвания NoSQL баз данных. В докладе мы рассмотрим, как использовать этот потенциал по максимуму в своих Python/Django приложениях.","tags":"Пишем web-проекты","title":"Пишем web-проекты: выжимаем максимум из PostgreSQL","url":"http://pynsk.ru/posts/2015/сент./03/pishem-web-proekty-vyzhimaem-maksimum-iz-postgresql/"},{"text":"Разработка программ сопряжена с сложностями. Произвольно или нет лезут различные баги. Для поиска ошибок применяют различные инструменты, например дебаг. Дебаг бывает кустарным - print'ами, а есть более каноничный подход - дебаггерами. С десктоп программами все ясно - сиди тыкай точки остановки и изучай состояние программы, а что делать с web? А делать вот что - ставить debug toolbar: https://github.com/django-debug-toolbar/django-debug-toolbar Именно этот для Django, но такие есть и для других фреймворков.","tags":"Полезные инструменты","title":"Полезные инструменты: django-debug-toolbar","url":"http://pynsk.ru/posts/2015/сент./02/poleznye-instrumenty-django-debug-toolbar/"},{"text":"Тесты можно писать прям в коде, а точнее в docstring. Модуль doctest ищет куски текста, которые выглядят как интерактивные сессии Python и затем выполняет эти сессии, чтобы проверить, что они работают точно так же, как показано. Есть несколько стандартных причин, чтобы использовать doctest: Для того, чтобы проверить актуальность строк документации, убедившись, что все интерактивные примеры работают именно так, как задокументировано. Чтобы организовать регрессионное тестирование, проверяя, что интерактивные примеры из тестового файла или тестового объекта работают как ожидается. Чтобы написать руководство для пакета, иллюстрированное примерами ввода-вывода. В зависимости от того, на что обращается внимание - на примеры или на пояснительный текст, это можно назвать либо \"литературным тестированием\", либо \"исполняемой документацией\". Существует отличная статья про doctest - http://python-lab.ru/documentation/27/stdlib/doctest.html , поэтому здесь повторяться не буду.","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: doctest","url":"http://pynsk.ru/posts/2015/сент./01/testy-testy-testy-doctest/"},{"text":"Множество в python - \"контейнер\", содержащий не повторяющиеся элементы в случайном порядке. >>> a = set () >>> a set () >>> a = set ( 'hello' ) >>> a { 'h' , 'o' , 'l' , 'e' } >>> a = { 'a' , 'b' , 'c' , 'd' } >>> a { 'b' , 'c' , 'a' , 'd' } >>> a = { i ** 2 for i in range ( 10 )} # генератор множеств >>> a { 0 , 1 , 4 , 81 , 64 , 9 , 16 , 49 , 25 , 36 } >>> a = {} # А так нельзя! >>> type ( a ) < class ' dict '> Ссылки по теме: http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html http://server.179.ru/tasks/python/2014b1/17-sets.html http://informatics.mccme.ru/mod/book/view.php?id=6693","tags":"Синтаксис Python","title":"Синтаксис Python: множества (set)","url":"http://pynsk.ru/posts/2015/авг./31/sintaksis-python-mnozhestva-set/"},{"text":"При чтении чужого кода можно столкнутся с многими непонятными конструкциями. А сейчас хочу коротко осветить такую конструкцию как yield. Yield - это ключевое слово которое используется так же, как и слово return. Разница в том, что функция при этом начинает возвращать генератор вместо значения. def generator (): for i in ( 1 , 2 , 3 ): yield i g = generator () print ( g ) < generator object generator at 0x2e58870 > for i in g : print ( i ) 1 2 3 В данном случае, с практической точки зрения, это бесполезный пример. Ощутимую пользу вы получите в ситуации, когда ваша функция должна будет возвращать достаточно большой объём данных, но использовать их надо будет только один раз. Для того чтобы до конца освоить оператор yield, вы должны знать, что когда вы вызываете функцию, в теле которой находится yield, выполнение этой функции не происходит. Вместо выполнения, функция вернёт объект-генератор. Выглядит это несколько странно на первый взгляд - функция вызвана, но код не выполнен, но, просто запомните этот факт. Код будет выполнятся при каждой итерации - будь то цикл \"for <...> in \" или вызов метода .next(). Ссылки по теме: http://zetblog.ru/programming/201304/python-iterators-generators-yield/ http://habrahabr.ru/post/132554/ http://www.ibm.com/developerworks/ru/library/l-pycon/ http://blog.jetfix.ru/post/chto-takoe-yield-i-dlya-chego-eto-slovo-nuzhno","tags":"Синтаксис Python","title":"Синтаксис Python: оператор yield","url":"http://pynsk.ru/posts/2015/авг./31/sintaksis-python-operator-yield/"},{"text":"Абстрактные базовые классы и интерфейсы — близкие по назначению и смыслу сущности. Как первые, так и вторые представляют собой своеобразный способ документирования кода и помогают ограничить (decouple) взаимодействие отдельных абстракций в программе (классов). Питон — очень гибкий язык. Одна из граней этой гибкости — возможности, предоставляемые метапрограммированием. И хотя в ядре языка абстрактные классы и интерфейсы не представлены, первые были реализованы в стандартном модуле abc, вторые — в проекте Zope (модуль zope.interfaces). Начиная с версии языка 2.6 в стандартную библиотеку включается модуль abc, добавляющий в язык абстрактные базовые классы (далее АБК). АБК позволяют определить класс, указав при этом, какие методы или свойства обязательно переопределить в классах-наследниках http://habrahabr.ru/post/72757/ https://docs.python.org/3/library/abc.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: abc","url":"http://pynsk.ru/posts/2015/авг./30/tainstvo-standartnoi-biblioteki-abc/"},{"text":"Часто утверждают, что Python жрет очень много памяти. В этом видео вы узнаете как Python работает с памятью","tags":"Внутренности Python","title":"Внутренности Python: на что уходит память","url":"http://pynsk.ru/posts/2015/авг./30/vnutrennosti-python-na-chto-ukhodit-pamiat/"},{"text":"Идеальный программист не пишет тесты, потому что у него не бывает ошибок. А сверх идеальный программист даже код не пишет. А так как идеальных нет, поэтому бывают медленные куски программы. Точнее как, обычно это называем \"тормозит\". Чтобы понять какое место тормозит можно воспользоваться модулем pycallgraph - https://github.com/gak/pycallgraph Данный модуль строит красивые графики-графы, в которых цветом выделяет медленные места программы. Очень удобно.","tags":"Полезные инструменты","title":"Полезные инструменты: pycallgraph","url":"http://pynsk.ru/posts/2015/авг./29/poleznye-instrumenty-pycallgraph/"},{"text":"Развитие общества обладает цикличностью. Лет 30-25 назад были популярны чаты, лет 15-10 назад тоже чаты были на коне. И сейчас снова. Только теперь это называют словом мессенджер. Хочется привести информацию о создании бота для мессенджера Telegram. 24 июня разработчики Telegram открыли платформу для создания ботов. Прежде всего, бот для Telegram — это по-прежнему приложение, запущенное на вашей стороне и осуществляющее запросы к Telegram Bot API. Причем API довольное простое — бот обращается на определенный URL с параметрами, а Telegram отвечает JSON объектом. http://habrahabr.ru/post/262247/","tags":"Python на службе народа","title":"Python на службе народа: создаем бота для Telegram","url":"http://pynsk.ru/posts/2015/авг./28/python-na-sluzhbe-naroda-sozdaem-bota-dlia-telegram/"},{"text":"IPython - интерактивная оболочка для языка программирования Python, которая предоставляет расширенную интроспекцию, дополнительный командный синтаксис, подсветку кода и автоматическое дополнение. IPython весьма удобен для демонстраций и экспериментов. В отличие от стандартного REPL, IPython может запоминать введенные команды. А IPython Notebook позволяет сохранить все свои эксперименты в файл, после чего залить на сервис для просмотра другими. Даже github поддерживает отображение этих \"книг\". IPython хорошо себя зарекомендовал из-за расширений. С помощью расширений можно подключать самые различные модули. И что немного \"странно\" - использовать другие языки совместно с Python. Например, вы можете написать часть своего эксперимента на R, а часть на Python - и они будут работать совместно.","tags":"Полезные инструменты","title":"Полезные инструменты: IPython","url":"http://pynsk.ru/posts/2015/авг./28/poleznye-instrumenty-ipython/"},{"text":"Существует два основных подхода в программировании - декларативный и императивный. Каждый из них имеет свои достоинства и недостатки. Крайнее время декларативный подход, а в частности функциональное программирование стало весьма популярным. Давайте ознакомимся с ним:","tags":"Функциональный Python","title":"Функциональный Python: пробуем функциональщину","url":"http://pynsk.ru/posts/2015/авг./27/funktsionalnyi-python-probuem-funktsionalshchinu/"},{"text":"Django - это крупный web-фреймворк. Это отличный инструмент для создания web-приложений. Освоение этого инструмента занимает приличное количество времени. А начать можно с туториала - https://docs.djangoproject.com/en/stable/intro/tutorial01/","tags":"Пишем web-проекты","title":"Пишем web-проекты: туториал по django","url":"http://pynsk.ru/posts/2015/авг./26/pishem-web-proekty-tutorial-po-django/"},{"text":"В PyPi репозитории не один шаблонизатор HTML. Но далеко не всегда хочется тащить его за собой. В этом случае нам поможет модуль Yattag - это библиотека (DSL по сути), которая позволяет в Python-way формате писать HTML/XML файлы Ознакомьтесь с туториалом: http://www.yattag.org/#tutorial","tags":"Полезные библиотеки","title":"Полезные библиотеки: генерация html с помощью Yattag","url":"http://pynsk.ru/posts/2015/авг./26/poleznye-biblioteki-generatsiia-html-s-pomoshchiu-yattag/"},{"text":"Без API уже тяжело представить веб-проект. Для django существует несколько библиотек, которые позволяют создать REST API за пару строк.","tags":"Пишем web-проекты","title":"Пишем web-проекты: обзор и сравнение методов реализации REST API в Django","url":"http://pynsk.ru/posts/2015/авг./25/pishem-web-proekty-obzor-i-sravnenie-metodov-realizatsii-rest-api-v-django/"},{"text":"Python 3 вышел в 2008 году, однако, до сих пор не все перешли на новую версию. Раньше основными аргументами, чтобы не начинать новые проекты на Python были - библиотеки не готовы к использованию, нет особых фич. Первое уже вполне решено - https://python3wos.appspot.com/ А второе, начиная с Python 3.3 уже слабо актуально - много новых фич введено. Поэтому теперь актуально писать совместимый код. Для наиболее легкого написания кода одинаково работающего как в Python 2.6+ так и в Python 3.* рекомендуется использовать библиотеку six. В ней собрано большее количество инструментов позволяющих писать кросверсионный код для Python 2.x-3.x. Для нахождения мест подлежащих изменению рекомендуется воспользоваться утилитами 2to3 или python-modernize. https://pythonhosted.org/six/ http://docs.python.org/2.7/library/2to3.html https://github.com/mitsuhiko/python-modernize","tags":"Опыт разработчиков","title":"Опыт разработчиков: пишем совместимый код (Python 2 и 3)","url":"http://pynsk.ru/posts/2015/авг./25/opyt-razrabotchikov-pishem-sovmestimyi-kod-python-2-i-3/"},{"text":"Конструкция with ... as используется для оборачивания выполнения блока инструкций менеджером контекста. Иногда это более удобная конструкция, чем try...except...finally . Синтаксис конструкции with ... as : \"with\" expression [ \"as\" target ] ( \",\" expression [ \"as\" target ]) * \":\" suite Теперь по порядку о том, что происходит при выполнении данного блока: Выполняется выражение в конструкции with ... as . Загружается специальный метод __exit__ для дальнейшего использования. Выполняется метод __enter__ . Если конструкция with включает в себя слово as , то возвращаемое методом __enter__ значение записывается в переменную. Выполняется suite. Вызывается метод __exit__ , причём неважно, выполнилось ли suite или произошло исключение. В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение None, если исключения не было. Примером использования данной конструкции является чтение и запись из/в файл (гарантированное закрытие файла) http://effbot.org/zone/python-with-statement.htm http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html https://docs.python.org/2/reference/compound_stmts.html","tags":"Синтаксис Python","title":"Синтаксис Python: with ... as","url":"http://pynsk.ru/posts/2015/авг./24/sintaksis-python-with-as/"},{"text":"Когда мне необходимо быстро вникнуть в синтаксис языка X, то использую этот сайт: http://learnxinyminutes.com/docs/ru-ru/python3-ru/ А по ссылке вы найдете синтаксис языка Python","tags":"Синтаксис Python","title":"Синтаксис Python: знакомимся с синтаксисом за Y минут","url":"http://pynsk.ru/posts/2015/авг./24/sintaksis-python-znakomimsia-s-sintaksisom-za-y-minut/"},{"text":"Самый популярный Python это CPython. Он настолько популярен, что когда говорят Python имеют ввиду именно каноническую реализацию - CPython. CPython, как можно понять из названия, имеет какое-то отношение к языку C. Из Python вы можете с помощью ctypes дергать С-шные функции. Однако, этот механизм несколько медленный и не всегда удобный - бывает надо просто дернуть один кусок C-кода. Или надо только часть от h-файла, или только кусок структуры. Вот в этом случае помогает - cffi. Пример кода с использованием этой библиотеки: >>> from cffi import FFI >>> ffi = FFI () >>> ffi . cdef ( \"\"\" .......int printf(const char *format, ...); // copy-pasted from the man page .......\"\"\" ) >>> C = ffi . dlopen ( None ) # loads the entire C namespace >>> arg = ffi . new ( \"char[]\" , \"world\" ) # equivalent to C code: char arg[] = \"world\"; >>> C . printf ( \"hi there, %s . \\n \" , arg ) # call printf hi there , world . 17 # this is the return value >>> Эти многоточия в cdef это реальный код, который надо писать. https://cffi.readthedocs.org/en/latest/ https://pypi.python.org/pypi/cffi","tags":"Hardcore Python","title":"Hardcore Python: запускаем С код с помощью cffi","url":"http://pynsk.ru/posts/2015/авг./23/hardcore-python-zapuskaem-s-kod-s-pomoshchiu-cffi/"},{"text":"Стандартная поставка Python полна возможностями. Хочется упомянуть обобщенные функции. Если простыми словами, то это такие функции, где мы не думаем о типах аргументов, а просто пишем логику. Например, (натянутый пример) оператор \"+\" - мы не думаем о аргументах, мы просто складывает два объекта. Для реализации обобщенных функций в Python 3 (начиная с 3.4) появился метод singledispatch в модуле functools. Подробней о этом механизме по ссылке - https://www.python.org/dev/peps/pep-0443/","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки:  functools.singledispatch","url":"http://pynsk.ru/posts/2015/авг./23/tainstvo-standartnoi-biblioteki-functoolssingledispatch/"},{"text":"Понятное представление информации - это вечная задача. Причем она свойственна всем. Хочется упомянуть графики. Вот собрали мы данные, задача была не простая, а теперь надо их представить. Графики бывают разных типов, их очень много. Даже если какой-то график сделали, а как поделиться? Можно скинуть картинку, да только придется потом с \"линейкой\" вычислять значения, а можно пойти по другому пути - https://plot.ly/python/. ploy.ly предоставляет возможно создать динамический график, например, https://plot.ly/python/dashboard/ plot.ly позволяет создавать самые разные графики, которые будут выглядеть как живые - можно будет методом тыка узнать значение графика в точке, покрутить, повертеть график.","tags":"Полезные библиотеки","title":"Полезные библиотеки: plot.ly (plotly)","url":"http://pynsk.ru/posts/2015/авг./22/poleznye-biblioteki-plotly-plotly/"},{"text":"NumPy — это библиотека языка Python, добавляющая поддержку больших многомерных массивов и матриц, вместе с большой библиотекой высокоуровневых (и очень быстрых) математических функций для операций с этими массивами. В чем же \"фишка\" NumPy вы можете спросить. Основным объектом NumPy является однородный многомерный массив (в numpy называется numpy.ndarray). Это многомерный массив элементов (обычно чисел), одного типа. Здесь можно подчеркнуть одного типа . Эта существенная деталь позволяет заметно ускорить работу с такими объектами. Зная, что данный объект имеет только, скажем, целые числа, то не будут производится проверки типов. Плюс к этому - уменьшается общий объем памяти для хранения таких объектов. http://pythonworld.ru/numpy/1.html http://www.numpy.org/","tags":"Полезные библиотеки","title":"Полезные библиотеки: numpy","url":"http://pynsk.ru/posts/2015/авг./22/poleznye-biblioteki-numpy/"},{"text":"Много хают GIL в Python, в этом видео вы узнаете насколько же он плох... или все-таки хорош? !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Внутренности Python","title":"Внутренности Python: зачем нужен GIL(Global interpreter lock)","url":"http://pynsk.ru/posts/2015/авг./21/vnutrennosti-python-zachem-nuzhen-gilglobal-interpreter-lock/"},{"text":"Raspberry Pi - это мини-компьютер, который имеет невысокую цену и при этом имеет богатые возможности. Применение мини-компьютеров широкое, например, можно сделать камеру для дома - можете реализовать программку, которая будет следить за вашим маленьким ребенком и посылать вам сигнал, когда ребенок проснулся. !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Python на службе народа","title":"Python на службе народа: распознаем образы с помощью Raspberry Pi","url":"http://pynsk.ru/posts/2015/авг./21/python-na-sluzhbe-naroda-raspoznaem-obrazy-s-pomoshchiu-raspberry-pi/"},{"text":"Трансдьюсеры — это попытка переосмыслить операции над коллекциями, найти в них общую идею и принцип, научиться совмещать вместе несколько операций для их дальнейшего переиспользования. !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Интересные концепции","title":"Интересные концепции: Трансдьюсеры","url":"http://pynsk.ru/posts/2015/авг./20/interesnye-kontseptsii-transdiusery/"},{"text":"Внимание внимание внимание, в середине сентября, а именно, 13 сентября в 13 часов пройдет встреча Python-сообщества PyNSK. Подробности по ссылке - https://vk.com/pynsk_13_09_2015 На встрече вас ожидает два полноценных доклада и один мини-доклад: Доклад Игоря Старикова (основатель Python сайта http://pythonz.net/ ) - \"Разработчик разработчику: Азбука вежливости\" Доклад Артёма Попова https://vk.com/id42320764 - \"Python в музыке. osc, midi и asyncio\" Мини-доклад Алесандра Сапронова ( https://vk.com/sapronov.alexander ), который расскажет о новостях из мира Python: \"Commit ускоривший Python 2.7.11 на 30% и новое в Python 3.5\"","tags":"Встречи","title":"Анонс встречи №2 сообщества PyNSK","url":"http://pynsk.ru/posts/2015/авг./20/anons-vstrechi-2-soobshchestva-pynsk/"},{"text":"Представим, написали мы функцию: def super_function ( server_name , host ): .... print ( server_name ) ........... .... run_server ( host ) Но вот беда, первый аргумент - имя сервера у вас уже есть. А второй, ip сервера, вы получите от пользователя, а функцию уже надо вызвать. Можно, конечно, дождаться когда будет два аргумента, тогда и запустить. А можно пойти по другому пути - воспользоваться механизмом каррирования - такое страшное слово. Каррирование - преобразование функции от (предположим) двух аргументов в функцию от первого аргумента, возвращающую функцию, результат вызова которой со вторым агрументом эквивалентен вызову первоначальной функции с упомянутыми аргументами. Мощный механизм, который нам и поможет. Пишем from functools import partial my_func = partial ( super_function , 'My super server' ) .... .... host = '127.0.0.1' my_func ( host ) https://docs.python.org/3.4/library/functools.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: functools.partial","url":"http://pynsk.ru/posts/2015/авг./20/tainstvo-standartnoi-biblioteki-functoolspartial/"},{"text":"Вот вы написали web-проект, теперь надо его опубликовать на хостинге (или у себя на машине) (задеплоить). Начинаете жадно мучать гугл странными запросами. И вот наконец-то доходите до слов - uwsgi и gunicorn. Это серверы, которые с одной стороны предоставляют пользователям доступ к вашему проекту(сайтику), а с другой - общаются с вашим Python кодом. Стоит сказать, что gunicorn это WSGI HTTP сервер, написанный на питоне и легкий в настройке. Среди заявленных возможностей: поддержка WSGI, Django и Paster async, sync worker балансировка нагрузки через pre-fork и shared socket разные хуки для расширение возможностей Этот инструмент простой для понимания. Рекомендуем его использовать. http://gunicorn.org/","tags":"Полезные инструменты","title":"Полезные инструменты: gunicorn","url":"http://pynsk.ru/posts/2015/авг./19/poleznye-instrumenty-gunicorn/"},{"text":"Извлечение информации из текста/web-страниц сопряжено с эвристиками. Одна из проблем, с которой сталкиваются разработчики - как парсить даты. Даты можно написать 100 и одним способом: tomorrow, а еще 4/4/80 или March 5th, 1980. И какой код писать, чтобы понять эти даты? К счастью, код уже написан - https://github.com/bear/parsedatetime Данная библиотека позволяет спарсить время в самых различных форматах.","tags":"Извлечение информации","title":"Извлечение информации: парсинг дат/времени","url":"http://pynsk.ru/posts/2015/авг./19/izvlechenie-informatsii-parsing-datvremeni/"},{"text":"Не секрет, что Python (CPython) - динамически типизируемый язык (все типы выясняются во время выполнения программы). Это как дар так и проклятие. С одной стороны - можно быстрее писать программы, с другой - тяжелее найти ошибки. При этом, если была бы статическая типизация - уже на этапе компиляции мы знали бы где мы затупили с типами. В этом видео рассказывается, как же можно использовать опциональную статическую типизацию в Python !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Статическая типизация в Python","title":"Статическая типизация в Python: сила опциональной типизации","url":"http://pynsk.ru/posts/2015/авг./18/staticheskaia-tipizatsiia-v-python-sila-optsionalnoi-tipizatsii/"},{"text":"nose — это инструмент для прогона тестов посредством unittest (и doctest, с ключом --with-doctest). Имеет также собственное API, использовать которое необязательно. nose автоматически собирает тесты из файлов вида test_*, достаточно умен, чтобы заглянуть в папочку tests при наличии таковой, умеет измерять покрытие кода (code coverage) при помощи coverage.py (--with-coverage). Также можно запустить только тесты, которые отвалились в последний прогон (--failed). https://nose.readthedocs.org/en/latest/","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: nose","url":"http://pynsk.ru/posts/2015/авг./18/testy-testy-testy-nose/"},{"text":"Pycharm - это IDE специализированная под Python разработку. Возможности этого редактора кода захватывают: - Статический анализ кода, подсветка синтаксиса и ошибок. - Рефакторинг: переименование, извлечение метода, введение переменной, введение константы, подъём и спуск метода и т. д. - Инструменты для веб-разработки с использованием фреймворка Django - Встроенный отладчик для Python - Встроенные инструменты для юнит-тестирования - Поддержка систем контроля версий (Git, svn и другие) - По-мимо этого, Pycharm поддержку множество модулей, например, IPython встроен в редактор. https://www.jetbrains.com/pycharm/","tags":"Полезные инструменты","title":"Полезные инструменты: Pycharm","url":"http://pynsk.ru/posts/2015/авг./17/poleznye-instrumenty-pycharm/"},{"text":"Все типы данных в Python относятся к одной из 2-х категорий: изменяемые (mutable) и неизменяемые (unmutable). Многие из предопределённых типов данных Python — это типы неизменяемых объектов: числовые данные (int, float, complex), символьные строки (class 'str'), кортежи (tuple). Другие типы определены как изменяемые: списки (list), множества (set), словари (dict). Вновь определяемые пользователем типы (классы) могут быть определены как неизменяемые или изменяемые. Изменяемость объектов определённого типа является принципиально важной характеристикой, определяющей, может ли объект такого типа выступать в качестве ключа для словарей (dict) или нет. Подробнее по ссылке - https://www.ibm.com/developerworks/ru/library/l-python_details_02/","tags":"Синтаксис Python","title":"Синтаксис Python: изменяемые и неизменяемые типы данных","url":"http://pynsk.ru/posts/2015/авг./17/sintaksis-python-izmeniaemye-i-neizmeniaemye-tipy-dannykh/"},{"text":"Cython — язык программирования, упрощающий написание модулей С/С++ кода для Python. Кроме стандартного синтаксиса Python, поддерживаются: Прямой вызов функций и методов С/С++ из кода на Cython; Строгая типизация переменных, классов, атрибутов классов. Код Cython преобразуется в С/С++ код для последующей компиляции и впоследствии может использоваться как расширение стандартного Python или как независимое приложение со встроенной библиотекой выполнения Cython. Программирование на Cyhton не очень отличается от Python: cdef ackermann(int m, int n): ....if m == 0: ........return n + 1 ....elif n == 0: ........return ackermann(m - 1, 1) ....else: ........return ackermann(m - 1, ackermann(m, n - 1)) print(\"Ackermann:\") print(ackermann(0, 3)) print(ackermann(1, 4)) Отличается в необходимости указывать типы переменных (это в основном). Хорошее применение языка - связка с C/C++ кодом - оно происходит в разы быстрее, чем в CPython и PyPi. Скорость исполнения программы также выше (может достигать сотен раз). http://cython.org/ https://www.wikiwand.com/ru/Cython","tags":"Hardcore Python","title":"Python hardcore: Cython","url":"http://pynsk.ru/posts/2015/авг./16/python-hardcore-cython/"},{"text":"Celery — распределенная очередь заданий И так, что же умеет Celery: Выполнять задания асинхронно или синхронно Выполнять периодические задания(умная замена crond) Выполнять отложенные задания Распределенное выполнение (может быть запущен на N серверах) В пределах одного worker'а возможно конкурентное выполнение нескольких задач(одновременно) Выполнять задание повторно, если вылез exception Ограничивать количество заданий в единицу времени(rate limit, для задания или глобально) Routing заданий(какому worker'у что делать) Несложно мониторить выполнение заданий Выполнять подзадания Присылать отчеты об exception'ах на email Проверять выполнилось ли задание(удобно для построения Ajax приложений, где юзер ждет факта завершения) Применение очередей задач широкое - если у вас есть задачи, которые можно выполнить не прям сейчас, а чуть позже - то стоит использовать. Примеры таких задач - парсинг RSS, отправка Email. http://www.celeryproject.org/","tags":"Полезные библиотеки","title":"Python и асинхронные задачи","url":"http://pynsk.ru/posts/2015/авг./16/python-i-asinkhronnye-zadachi/"},{"text":"Графики бывают совсем разные. Де-факто стандартом в питоне для построения графиков является matplotlib. Это такой комбайн, который умеет очень много, даже 3Д графики. Matplotlib написан и поддерживался в основном Джоном Хантером (англ. John Hunter) и распространяется на условиях BSD-подобной лицензии. Генерируемые в различных форматах изображения могут быть использованы в интерактивной графике, в научных публикациях, графическом интерфейсе пользователя, веб-приложениях, где требуется построение диаграмм. http://matplotlib.org/","tags":"Полезные библиотеки","title":"Рисование графиков на Python","url":"http://pynsk.ru/posts/2015/авг./15/risovanie-grafikov-na-python/"},{"text":"Pygame - это кроссплатформенная библиотека языка Python, предназначенная для написания компьютерных игр и мультимедиа приложений. Для знакомства с возможностями PyGame ссылки: http://habrahabr.ru/post/130726/ http://habrahabr.ru/post/130726/ http://habrahabr.ru/post/164229/ http://habrahabr.ru/post/193888/ http://www.pygame.org/","tags":"Python в играх","title":"Python в играх: PyGame","url":"http://pynsk.ru/posts/2015/авг./15/python-v-igrakh-pygame/"},{"text":"Сегодня вашему вниманию представляется статья и небольшая инфографика, которая покажет вам на конкретных примерах, что Python столь же эффективен в разработке игр, как и в других областях. http://tproger.ru/articles/python-powered-games/","tags":"Python в играх","title":"Python в играх: где используется Python?","url":"http://pynsk.ru/posts/2015/авг./14/python-v-igrakh-gde-ispolzuetsia-python/"},{"text":"Программирование должно упрощать жизнь. Распознавание образов это интересная задача, но далеко не всегда надо обучать нейронную сеть, вычислять на видеокарте. OpenCV это библиотека компьютерного зрения. Которая ОЧЕНЬ много умеет чего. По ссылке вы сможете найти пример использование OpenCV для определения \"Выключил ли я духовку?\" http://kazuar.github.io/light-detection-opencv/","tags":"Python на службе народа","title":"Python на службе народа: Я выключил духовку?","url":"http://pynsk.ru/posts/2015/авг./14/python-na-sluzhbe-naroda-ia-vykliuchil-dukhovku/"},{"text":"","tags":"Hardcore Python","title":"Python оптимизации: сверхоптимизация кода на Python","url":"http://pynsk.ru/posts/2015/авг./13/python-optimizatsii-sverkhoptimizatsiia-koda-na-python/"},{"text":"Признак того, что объект не должен быть классом — если в нём всего 2 метода, и один из них — инициализация, __init__ . Каждый раз видя это, подумайте: «наверное, мне нужна просто одна функция». http://habrahabr.ru/post/140581/ http://habrahabr.ru/post/143620/","tags":"Опыт разработчиков","title":"Опыт разработчиков: \"Перестаньте писать классы\"","url":"http://pynsk.ru/posts/2015/авг./13/opyt-razrabotchikov-perestante-pisat-klassy/"},{"text":"Для сбора данных с Web-страниц в Python существует библиотека mechanize, автоматизирующая взаимодействие с Web-сайтами. Часто используемая совместно с ней библиотека Beautiful Soup помогает понять тот «почти-HTML» код, который обычно находится на Web-сайтах. http://www.ibm.com/developerworks/ru/library/l-python-mechanize-beautiful-soup/","tags":"Извлечение информации","title":"Парсинг и Python: mechanize","url":"http://pynsk.ru/posts/2015/авг./12/parsing-i-python-mechanize/"},{"text":"Asyncio - это модуль содержащий инфраструктуру пригодную для написания асинхронных сетевых приложений. Благодаря концепции сопрограмм (coroutines), код асинхронного приложения прост для понимания и поддержки. Экосистема развивается не по дням, а по часам. Стоит обратить внимание на развитие этого направления современного Python http://sysdev.me/python-asyncio/ https://docs.python.org/3/library/asyncio.html https://docs.python.org/3/library/asyncio-dev.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: примеры для asyncio - aiohttp","url":"http://pynsk.ru/posts/2015/авг./12/tainstvo-standartnoi-biblioteki-primery-dlia-asyncio-aiohttp/"},{"text":"При написании тестов не редка ситуация, когда надо иметь фиксированное воспроизводимое много раз состояние программы. Например, такая-то кнопочка нажата, такой-то класс содержит такие-то значения. Чтобы не приходилось каждый раз вручную создавать подобное состояние программы используются fixture (фикстуры). Фикстуры позволяют сохранить состояние системы в файл, а потом его от туда загрузить. По-мимо тестов, фикстуры применяются для создания начального состояния системы. Например, есть проект, который использует базу данных(БД). И возникает задача развернуть проект на новом компьютере. Можно перетаскивать БД и чистить от лишнего. А можно сохранить первичное состояние в файле и затем его подгрузить. Ссылки для погружения: http://farmdev.com/projects/fixture/ http://pythontesting.net/framework/pytest/pytest-fixtures-easy-example/ https://docs.djangoproject.com/en/1.8/howto/initial-data/","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: что такое фикстура (fixture)?","url":"http://pynsk.ru/posts/2015/авг./11/testy-testy-testy-chto-takoe-fikstura-fixture/"},{"text":"Тесты не всегда универсальны. Например, в Windows надо дергать одну программу, в Linux другую. Чтобы реализовать такую логику в pytest можно воспользоваться - skipif import sys @pytest.mark.skipif ( sys . version_info < ( 3 , 3 ), reason = \"requires python3.3\" ) def test_function (): ... Вот такой пример демонстрирует как можно пропустить тест, если запуск происходит в Python версии ниже 3.3.","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: пропускаем тесты в pytest по условию","url":"http://pynsk.ru/posts/2015/авг./11/testy-testy-testy-propuskaem-testy-v-pytest-po-usloviiu/"},{"text":"Репозиторий pypi содержит более 62к модулей. Такое количество готовых инструментов, в дополнение к богатой стандартной поставке, позволяет заметно упростить разработку новых проектов. Вот только новички сталкиваются с проблемой установки этих самых модулей. Стандартным способом установки новых модулей является pip (и easy_install). pip https://pip.pypa.io/en/latest/index.html это инструмент, который упрощает управление модулями. Вы можете установить модуль, например numpy: pip install numpy Удалить, его же: pip unistall numpy Можете получить список библиотеки уже установленных - pip list Это не весь список команд, но и его достаточно для установки библиотек буквально в 1 команду.","tags":"Разное","title":"Установка библиотек в Python","url":"http://pynsk.ru/posts/2015/авг./10/ustanovka-bibliotek-v-python/"},{"text":"Статья от Rafe Kettler. Что такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, init или lt ). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации. Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание. http://habrahabr.ru/post/186608/","tags":"Таинство стандартной библиотеки","title":"Магические методы в Python","url":"http://pynsk.ru/posts/2015/авг./10/magicheskie-metody-v-python/"},{"text":"Модуль collections - предоставляет специализированные типы данных, на основе словарей, кортежей, множеств, списков. Этот модуль хорошо себя показывает при частой работе со словарями и списками. Например, данный модуль предоставляет возможность посчитать n наиболее часто встречающихся элементов, в порядке убывания встречаемости. Есть в этом модуле и словарь, который помнит порядок ключей. А еще есть структура, которая позволяет создать объект ведущий себя как кортеж, с тем дополнением, что каждому элементу присваивается имя, по которому можно в дальнейшем получать доступ. Заинтересовал? Вот ссылки для дальнейшего погружения в тему: https://docs.python.org/3.5/library/collections.html http://pythonworld.ru/moduli/modul-collections.html","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: collections","url":"http://pynsk.ru/posts/2015/авг./09/tainstvo-standartnoi-biblioteki-collections/"},{"text":"Стандартная поставка Python содержит множество инструментов для решения задач. Например, для работы с датами отлично себя показывают datetime и calendar Модуль datetime предоставляет классы для обработки времени и даты разными способами. Поддерживается и стандартный способ представления времени, однако больший упор сделан на простоту манипулирования датой, временем и их частями. Модуль calendar позволяет напечатать себе календарик (а также содержит некоторые другие полезные функции для работы с календарями). Возможности этих модулей обширны. Стоит их рассмотреть внимательно. Для этого приведем ссылки: datetime: https://docs.python.org/2/library/datetime.html http://pythonworld.ru/moduli/modul-datetime.html http://pymotw.com/2/datetime/ calendar: https://docs.python.org/2/library/calendar.html http://pymotw.com/2/calendar/","tags":"Таинство стандартной библиотеки","title":"Таинство стандартной библиотеки: datetime и calendar","url":"http://pynsk.ru/posts/2015/авг./09/tainstvo-standartnoi-biblioteki-datetime-i-calendar/"},{"text":"Далеко не всегда требуется тащить мощный Django или другой фреймворк. Бывает достаточно небольшого количества чистого Python кода и базы данных. Посмотрим, как имея всего эти 2 элемента написать приложение. !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Пишем web-проекты","title":"Python и real-time web приложение","url":"http://pynsk.ru/posts/2015/авг./08/python-i-real-time-web-prilozhenie/"},{"text":"Qt - это инструментарий для разработки на C++, который предоставляет огромный спектр возможностей: от рисования GUI, до написания низкоуровневых серверов. Часто Qt применяют для создания GUI, в том числе в интерактивном режиме - можно перемещать виджеты на формы. Qt имеет отличную докумементацию, а также имеет привязку для Python - PyQt и PySide. (вторая еще с Qt5 не умеет работать) Используя PyQt можно нарисовать формочку в редакторе, а затем буквально одной строчкой начать писать логику. https://wiki.python.org/moin/PyQt http://wiki.python.su/Документации/ВведениеВСредуPyQt4","tags":"Полезные библиотеки","title":"Python + GUI == PyQt","url":"http://pynsk.ru/posts/2015/авг./08/python-gui-pyqt/"},{"text":"Информации очень много. Хорошо бы уметь ее фильтровать. Хочется упомянуть такое средство фильтрации как анализ тональности. Это даже не фильтрация, но можно применять как фильтр. Sentiment analysis (по-русски, анализ тональности) — это область компьютерной лингвистики, которая занимается изучением мнений и эмоций в текстовых документах. С помощью анализа тональности можно определить, что текст N интересный, а текст M неинтересный - причем это сделает компьютер за вас. Для погружения в эту тему стоит почитать эти ссылки: - http://habrahabr.ru/post/149605/ - http://habrahabr.ru/post/263171/ - http://habrahabr.ru/post/197890/","tags":"Python на службе народа","title":"Python как средство для определения \"хорошо/плохо\"","url":"http://pynsk.ru/posts/2015/авг./07/python-kak-sredstvo-dlia-opredeleniia-khoroshoplokho/"},{"text":"youtube-dl (https://github.com/rg3/youtube-dl/) - это очень популярный скрипт для выгрузки видео с сервиса Youtube (, Vimeo и других). Данная утилита позволяет очень легко выдернуть видео со страницы ютьюб. Множество настроек позволяют в том числе выдернуть субтитры, узнать длительность видео и многие другие параметры. Данную утилиту можно применить следующим образом: если у вас есть ряд каналов, которые вы смотрите регулярно, то часто задаетесь вопросом \"Вышло новое видео или нет?\". Чтобы не тыкаться по 10 раз на дню на сайт (плюс к этому, \"котики\" могут отвлечь на несколько часов), вы можете соединить несколько сервисов вместе и новые видео будут автоматически попадать к вам на компьютер.","tags":"Полезные инструменты","title":"Утилиты написанные на Python: youtube-dl","url":"http://pynsk.ru/posts/2015/авг./07/utility-napisannye-na-python-youtube-dl/"},{"text":"Развитие языка Python происходит согласно чётко регламентированному процессу создания, обсуждения, отбора и реализации документов PEP. PEP - Python Enhancement Proposal - это предложения по развитию питона https://www.python.org/dev/peps/ Процесс PEP является основным механизмом для предложения новых возможностей и для документирования проектных решений, которые прошли в Python. Самым известным PEP является PEP8 - это свод рекомендаций в оформлению кода. Рекомендации написаны кровью из глаз программистов. https://www.python.org/dev/peps/pep-0008/","tags":"Разное","title":"Что такое PEP?","url":"http://pynsk.ru/posts/2015/авг./06/chto-takoe-pep/"},{"text":"Без баз данных (БД) в современной разработке редко обходится. Питон не обделен и имеет множество модулей для работы с базами данных. Есть и специализированные, например, pymongo - модуль для MongoDB, есть и более обширные - sqlalchemy, PonyORB. sqlalchemy - это ORM для различных БД. Если просто, то это инструмент, написать структуру данных и работать с ней, а \"алхимия\" будет самостоятельно сохранять/подгружать из БД данные. sqlalchemy умеет работать со всеми популярными реляционными БД.","tags":"Разное","title":"Python и базы данных: много баз - много модулей или один?","url":"http://pynsk.ru/posts/2015/авг./06/python-i-bazy-dannykh-mnogo-baz-mnogo-modulei-ili-odin/"},{"text":"Излечение информации со страниц может быть интересным. Рекомендуем к просмотру видео !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Извлечение информации","title":"Python и интересный парсинг сайтов","url":"http://pynsk.ru/posts/2015/авг./05/python-i-interesnyi-parsing-saitov/"},{"text":"bottle - это веб-фреймворк для Python. Отличительной особенностью этого фреймворка является простота - исходный код занимает один файл. Несмотря на свою минималистичность, Bottle предоставляет довольно широкие возможности, которых на 100% хватает для мелких и средних проектов. Чтобы стартануть изучение достаточно написать: from bottle import route , run , template @route ( '/hello/<name>' ) def index ( name ): return template ( '<b>Hello {{name}}</b>!' , name = name ) run ( host = 'localhost' , port = 8080 ) Это запустит web-приложение на 8080 порту, а по ссылке http://127.0.0.1/hello/Alexander вы увидите Hello Alexander. Очень просто. Дальнейшее изучение можно продолжить по ссылкам: http://bottlepy.org/docs/dev/index.html http://habrahabr.ru/post/221659/ http://habrahabr.ru/post/250831/","tags":"Пишем web-проекты","title":"Bottle с Python","url":"http://pynsk.ru/posts/2015/авг./05/bottle-s-python/"},{"text":"Наряду с входящими в стандартную поставку питона средствами для тестирования, существуют и альтернативные инструменты, например, py.test. http://pytest.org/ py.test имеет множество расширений, которые значительно упрощают написание тестов. py.test имеет плагины для всех популярных web-фреймворков, с помощью плагинов позволяет кэшеировать результаты (успешных тестов), формировать отчеты в самых различных форматах. А также имеет очень простую систему расширения и вы можете буквально за день написать свой плагин. !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: модуль тестирования py.test","url":"http://pynsk.ru/posts/2015/авг./04/testy-testy-testy-modul-testirovaniia-pytest/"},{"text":"Тесты тесты тесты: создание читаемых отчетов Когда в вашей программе очень много тестов, то возникают проблемы с чтением отчетов (что сломалось, что корректно отработало). Для создания читаемых отчетов можно порекомендовать allure-framework. О этом фреймворке можно узнать в видео: !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document); https://github.com/allure-framework","tags":"Тесты тесты тесты","title":"Тесты тесты тесты: создание читаемых отчетов","url":"http://pynsk.ru/posts/2015/авг./04/testy-testy-testy-sozdanie-chitaemykh-otchetov/"},{"text":"Стоит упомянуть про конструкцию switch в Python. Такой конструкции в языке нет, однако, выкрутится можно. Часто рекомендуют писать множественные elif'ы, но можно сделать так: def switch_case ( case ): return \"You entered \" + { '1' : \"one\" , '2' : \"two\" , '3' : \"three\" } . get ( case , \"an out of range number\" ) num = raw_input ( \"Input a number between 1 and 3: \" ) print switch_case ( num ) В этом примере мы создаем словарь, а затем получаем значение по нужному нам ключу. Вот только этот подход не работает, когда значение switch'а вычисляется в динамике. (Например, если мы приветствуем/прощаемся какого-то пользователя). result = { 'a' : lambda x : x * 5 , 'b' : lambda x : x + 7 , 'c' : lambda x : x - 2 }[ value ]( x ) В этом случае мы все также создаем словарь, но в качестве значений словаря прописываем функцию (в примере - lamdba функции). Затем получаем эту функцию словаря и вычисляем с аргументом. Еще способы реализации switch-case в Python: Recipe 410692: Readable switch construction without lambdas or dictionaries Recipe 410695: Exception-based Switch-Case Recipe 181064: Using a Dictionary in place of a 'switch' statement","tags":"Синтаксис Python","title":"Синтаксис Python: конструкция switch","url":"http://pynsk.ru/posts/2015/авг./03/sintaksis-python-konstruktsiia-switch/"},{"text":"Сегодня хочется упомянуть о непонятной на первый взгляд конструкции - тернарная условная операция, или по-русски - трехместное выражение if/else . Представим, есть такой код: if X : A = Y else : A = Z довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение if/else : A = Y if X else Z В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z. >>> >>> A = 't' if 'spam' else 'f' >>> A 't' Синтаксис конструкции if-elif-else описан по ссылкам https://docs.python.org/3/tutorial/controlflow.html http://pythonworld.ru/osnovy/instrukciya-if-elif-else-proverka-istinnosti-trexmestnoe-vyrazhenie-ifelse.html","tags":"Синтаксис Python","title":"Синтаксис Python: трехместное выражение if/else","url":"http://pynsk.ru/posts/2015/авг./03/sintaksis-python-trekhmestnoe-vyrazhenie-ifelse/"},{"text":"Для рисования векторных графиков (svg) подойдет библиотека pygal - http://pygal.org/ Данный модуль предоставляет широкий спектр возможностей, в частности можно нарисовать: Столбчатые диаграммы Линейные диаграммы XY диаграммы Круговые диаграммы Лепестковые диаграммы и другие","tags":"Полезные модули","title":"Рисование svg графиков","url":"http://pynsk.ru/posts/2015/авг./02/risovanie-svg-grafikov/"},{"text":"Статистический модуль теперь есть в стандартной библиотеке. Начиная с версии 3.4 в стандартной поставке Python появилось более продвинутое средство для работы с данными. Теперь нет необходимости писать руками методы average, median (вычисление среднего и медианы) и других. Ознакомьтесь с возможностями стандартного модуля: https://docs.python.org/3/library/statistics.html","tags":"Таинство стандартной библиотеки","title":"Статистический модуль в стандартной библиотеке","url":"http://pynsk.ru/posts/2015/авг./02/statisticheskii-modul-v-standartnoi-biblioteke/"},{"text":"Пишите под windows, да еще и с Win API? Python здесь тоже может помочь, ведь для него есть библиотека pywin32 (http://sourceforge.net/projects/pywin32/). Данная библиотека предоставляет все базовые примитивы для работы с WinAPI.","tags":"Полезные библиотеки","title":"Python + winapi","url":"http://pynsk.ru/posts/2015/авг./01/python-winapi/"},{"text":"Библиотека click ( http://click.pocoo.org/4/ ) позволяет с минимальными усилиями создать интерфейс командной строки. Создаете функцию, добавляете пару декораторов и готово. import click @click.command () @click.option ( '--count' , default = 1 , help = 'Number of greetings.' ) @click.option ( '--name' , prompt = 'Your name' , help = 'The person to greet.' ) def hello ( count , name ): ... А как вы создаете командные интерфейсы?","tags":"Полезные модули","title":"click","url":"http://pynsk.ru/posts/2015/авг./01/click/"},{"text":"Если вы широко используете JSON в своем проекте, то вам будет интересен DSL - JSL. JSL позволяет описывать модели, почти в какой-нибудь ORM, создавать объекты по этим моделям и как-то с ними работать. Интересный проект. https://github.com/aromanovich/jsl","tags":"Полезные библиотеки","title":"JSON DSL - JSL","url":"http://pynsk.ru/posts/2015/июля/31/json-dsl-jsl/"},{"text":"Python - язык общего назначения, может применяться где угодно. Не верите? На странице https://www.python.org/about/success/ представлены сферы и названия компаний, которые применяют этот язык. Впечатляет.","tags":"Разное","title":"Python - язык общего назначения","url":"http://pynsk.ru/posts/2015/июля/31/python-iazyk-obshchego-naznacheniia/"},{"text":"Возможно! Рассказ \"Управление памятью в real-time приложениях Python\" Антона Патрушева покажет как можно писать Python приложения с максимально быстрым откликом. https://events.yandex.ru/lib/talks/2075/","tags":"Hardcore Python","title":"Python и real-time?","url":"http://pynsk.ru/posts/2015/июля/30/python-i-real-time/"},{"text":"В последнее время любят сравнивать Python и R. Так давайте же почитаем сравнение этих двух языков. http://blog.dominodatalab.com/comparing-python-and-r-for-data-science/","tags":"Разное","title":"Сравнение R и Python","url":"http://pynsk.ru/posts/2015/июля/30/sravnenie-r-i-python/"},{"text":"Парсинг сайтов это вечная задача. Сайтов много, данных много и все они разные. Для задач парсинга существует великое разнообразие инструментов. В Python 3-ей версии появился стандартный модуль для создания асинхронных программ. И грех не воспользоваться данной возможностью. Примером парсинга на asyncio может послужить эта статья http://olegwock.net/blog/python/byistryiy-parsing-na-python-s-pomoshhyu-asyncio/","tags":"Извлечение информации","title":"Парсинг с помощью asyncio","url":"http://pynsk.ru/posts/2015/июля/29/parsing-s-pomoshchiu-asyncio/"},{"text":"Пишите web приложения? Тогда для вас не является новостью, что без API далеко не уедешь. Для фреймворка django существует несколько способов создать API за пару минут, да еще и с документацией. https://github.com/tomchristie/django-rest-framework https://github.com/marcgibbons/django-rest-swagger","tags":"Пишем web-проекты","title":"Django REST API","url":"http://pynsk.ru/posts/2015/июля/29/django-rest-api/"},{"text":"До сих путаетесь между функциями, методами, классами и объектами? Пора разобраться в этом. Данная статья расскажет, что такое Bound и UnBound методы, как можно в динамике добавлять поля в объект, как перегружать методы. http://0agr.ru/blog/2011/05/03/advanced-python-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B/","tags":"Синтаксис Python","title":"Классы и функции","url":"http://pynsk.ru/posts/2015/июля/28/klassy-i-funktsii/"},{"text":"Вы пишите тесты? Тогда вам знаком модуль mock (в Python3 находится в unittest). Это модуль, который позволяет сделать имитацию объекта. Это необходимо, когда пишите тесты на свой код, а этот код использует множество долгих приготовлений: сходить в БД, разобрать данные еще что-то. Вот в этом случае вы можете провести имитацию всех этих долгих приготовлений и сконцентрироваться на написании тестов для своего кода. В случае с файловой системой немного сложней. Вот надо какие-то файлы создавать,в них что-то писать. Засорять свою домашнюю директорию папками \"temp\"? Не обязательно, можно имитировать файловую систему с помощью mockfs. https://github.com/mockfs/mockfs","tags":"Тесты тесты тесты","title":"Имитация файловой системы с помощью mock","url":"http://pynsk.ru/posts/2015/июля/28/imitatsiia-failovoi-sistemy-s-pomoshchiu-mock/"},{"text":"Предположим, у нас есть задача - выдрать из крупного текстового файла (файла с логами) все IPv4 (адреса клиентов, например). Как это можно сделать? Хорошим инструментом для решения этой задачи являются регулярные выражения. Регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле. Возможно, вы уже встречались с записями типа: <([a-z]+)[&#94;>]*(?<!/)> Большая вероятность, что это было регулярное выражение. Регулярные выражения - это мощный инструмент, который стоит изучить и осознать. Не надо запоминать все конструкции, достаточно понять принцип. Для погружения в эту тему, рекомендуем эти материалы: http://tproger.ru/translations/regular-expression-python/ http://qntm.org/files/re/re.html http://habrahabr.ru/post/115825/ http://pep8.ru/doc/dive-into-python-3/7.html","tags":"Таинство стандартной библиотеки","title":"Регулярные выражения","url":"http://pynsk.ru/posts/2015/июля/27/reguliarnye-vyrazheniia/"},{"text":"Стандартная библиотека Python отличается хорошей документацией и широким ассортиментом готовых решений. Python предоставляет без малого 68 встроенных функций: это получение модуля числа, бинарное и hex представления числа, различные преобразование типов, сложение, возведение в степень и многие другие. https://docs.python.org/3.5/library/functions.html А вы знали, что в Python всё является объектом? Даже число >>> dir ( 5 ) [ '__abs__' , '__add__' , '__and__' , .... , 'denominator' , 'imag' , 'numerator' , 'real' ]","tags":"Таинство стандартной библиотеки","title":"Встроенные функции Python","url":"http://pynsk.ru/posts/2015/июля/27/vstroennye-funktsii-python/"},{"text":"PEP 471 (Python 3.5) добавил в модуль os новую функцию - scandir. Функция scandir возвращает генератор, который содержит директории по пути. Польза scandir состоит в производительности. Теперь os.listdir и os.walk будут работать в 2-20 раз быстрее. Пример: функция, которая возвращает генератор с директориями начинающиеся с точки: def subdirs ( path ): \"\"\"Yield directory names not starting with '.' under given path.\"\"\" for entry in os . scandir ( path ): if entry . name . startswith ( '.' ) and entry . is_dir (): yield entry . name","tags":"Таинство стандартной библиотеки","title":"PEP 471 (Python 3.5) добавил в модуль os новую функцию - scandir.","url":"http://pynsk.ru/posts/2015/июля/25/pep-471-python-35-dobavil-v-modul-os-novuiu-funktsiiu-scandir/"},{"text":"Родным модулем для построения GUI интерфейсов для Python программ является Tkinter. Данная библиотека позволяет построить несложные интерфейсы. Tkinter есть на всех платформах где есть Python. В Python ветки 2.x.x при импорте модуля Tkinter, он пишется в большой буквы (иначе возникает ошибка). При импорте tkinter в версиях 3.x.x Питона имя модуля пишется с маленькой буквы. Данный курс - http://younglinux.info/tkinter.php - \"Создание GUI на Python с помощью библиотеки Tkinter\" знакомит с особенностями разработки графического интерфейса пользователя на основе языка программирования Python(создание виджет и обработчиков событий, связывание с событиями и др.).","tags":"Полезные библиотеки","title":"Tkinter","url":"http://pynsk.ru/posts/2015/июля/25/tkinter/"},{"text":"Язык brainfuck для хранения данных использует ячейки (по-хорошему бесконечное число ячеек) и состоит всего из восьми команд, поэтому выучить его будет легко. В этой статье показан интерпретатор brainfuck на Python http://pythonworld.ru/primery-programm/interpretator-brainfuck.html","tags":"Python проекты","title":"Интерпретатор brainfuck на Python","url":"http://pynsk.ru/posts/2015/июля/25/interpretator-brainfuck-na-python/"},{"text":"На странице Python-wiki представлен огромный список пакетов для создания GUI на Python https://wiki.python.org/moin/GuiProgramming","tags":"Полезные библиотеки","title":"Набор GUI библиотек для Python","url":"http://pynsk.ru/posts/2015/июля/25/nabor-gui-bibliotek-dlia-python/"},{"text":"Disqus — веб-сервис, который предоставляет возможность добавить форму для интернет-обсуждений и комментариев на сайт пользователя использует Python. Сервис использует Python (Django). По заверениям Disqus - они являются самым крупным django приложением в web. https://disqus.com/","tags":"Python проекты","title":"Disqus - самое крупное django приложением в web.","url":"http://pynsk.ru/posts/2015/июля/24/disqus-samoe-krupnoe-django-prilozheniem-v-web/"},{"text":"По рейтингу TIOBE за июль 2015 Python находится на 5-ом месте, год назад был на 8-ом. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html","tags":"Разное","title":"TIOBE за июль 2015: Python находится на 5-ом месте","url":"http://pynsk.ru/posts/2015/июля/24/tiobe-za-iiul-2015-python-nakhoditsia-na-5-om-meste/"},{"text":"Интересно как работает Python? Рекомендуем изучить материалы: Интерпретатор Python: о чём думает змея? (часть I-III) - http://habrahabr.ru/post/206420/ Python изнутри. Введение - habrahabr.ru/company/buruki/blog/189972/ Python изнутри. Объекты. Голова - habrahabr.ru/company/buruki/blog/189986/ Python изнутри. Объекты. Хвост - habrahabr.ru/company/buruki/blog/190336/ Python изнутри. Структуры процесса - habrahabr.ru/company/buruki/blog/191032/","tags":"Внутренности Python","title":"Интересно как работает Python?","url":"http://pynsk.ru/posts/2015/июля/23/interesno-kak-rabotaet-python/"},{"text":"Как работает Python, что такое интерпретатор, как работает компилятор и что такое байт-код, далее расскажу о виртуальной машине (PVM) и о производительности Python. Также о альтернативных реализациях интерпретатора. http://adw0rd.com/2009/08/22/python-howto-work/","tags":"Внутренности Python","title":"Как работает Python?","url":"http://pynsk.ru/posts/2015/июля/23/kak-rabotaet-python/"},{"text":"В подавляющем большинстве проектов используется отправка сообщений на почтовые адреса клиентов/админов/отделов. На сколько утомительно каждый раз создавать шаблоны на файловой системе, задавать сигналы, использовать часто дублирующийся код для рендеринга и отправки. В конечном итоге встают задачи о фоновой отправке, об изменениях отправителя, приоритизации, повторной отправке сообщения в случае неудачи, частом редактировании по просьбе клиента/маркетологов, прикреплению к письму стандартных файлов в виде каких-то инструкций по применению продукта, или же стандартных документов, отчетов по клиентам, переводам и тд и тп. В больших проектах часто необходимо визуально разделять шаблоны на категории, для фильтрации, дабы не тратить время на редактирование менее важных шаблонов при рефакторинге, и во избежание путаницы с новым контентом, или при работе со старым. Для подобных решений существует простая батарейка, призванная решить большинство подобных проблем, и избавить Вас от лишнего кода, сопровождения и нервотрепки. http://habrahabr.ru/post/253445/","tags":"Полезные модули","title":"Django DB Mailer - батарейка для отправки email","url":"http://pynsk.ru/posts/2015/июля/22/django-db-mailer-batareika-dlia-otpravki-email/"},{"text":"requests - http://docs.python-requests.org/en/latest/ - универсальный (для python2, python3) модуль для создание HTTP запросов. Данный модуль позволяет очень просто послать запрос, получить данные. >>> r = requests . get ( 'https://api.github.com/user' , auth = ( 'user' , 'pass' )) >>> r . status_code 200 >>> r . headers [ 'content-type' ] 'application/json; charset=utf8' >>> r . encoding 'utf-8' >>> r . text u'{\"type\":\"User\"...' >>> r . json () { u'private_gists' : 419 , u'total_private_repos' : 77 , ... }","tags":"Полезные модули","title":"requests","url":"http://pynsk.ru/posts/2015/июля/22/requests/"},{"text":"Одним из основных инструментов для тестирования в Python - unittest Это стандартный модуль для реализации юнит-тестов на Python. Unittest это порт JUnit с Java, иными словами ООП стиль, что весьма удобно для тестирования и процедур, и классов. Возможностей в данном модуле довольно много: проверки (assert*), декораторы, позволяющие пропустить отдельный тест (@skip, @skipIf) или обозначить сломанные тесты (@expectedFailure) При написании тестов надо исходит из следующих принципов: Работа теста не должна зависеть от результатов работы других тестов. - Тест должен использовать данные, специально для него подготовленные, и никакие другие. - Тест не должен требовать ввода от пользователя - Тесты не должны перекрывать друг друга (не надо писать одинаковые тесты 20 раз). Можно писать частично перекрывающие тесты. - Нашли баг -> напиши тест - Тесты надо поддерживать в рабочем состоянии - Модульные тесты не должны проверять производительность сущности (класса, функции) - Тесты должны проверять не только то, что сущность работает корректно на корректных данных, но и то что ведет себя адекватно при некорректных данных.","tags":"Тесты тесты тесты","title":"unittest - основной инструмент тестирования","url":"http://pynsk.ru/posts/2015/июля/21/unittest-osnovnoi-instrument-testirovaniia/"},{"text":"unittest - https://docs.python.org/3.5/library/unittest.html - фреймворк для написания юнит-тестов. unittest является частью стандартной поставки.","tags":"Тесты тесты тесты","title":"unittest","url":"http://pynsk.ru/posts/2015/июля/21/unittest/"},{"text":"Если вы использовали Python достаточно долго, вы должны были хотя бы слышать о понятии «list comprehensions». Это способ уместить цикл for, блок if и присваивание в одну строку. Генератор списков - яркий пример «синтаксического сахара». То есть конструкции, без которой легко можно обойтись, но с ней намного лучше :) Генераторы списков, как это не странно, предназначены для удобной обработки списков, к которой можно отнести и создание новых списков, и модификацию существующих. Допустим, нам необходимо получить список нечетных чисел, не превышающих 25. В принципе, только познакомившись с работой команды xrange решить эту проблему несложно. >>> res = [] >>> for x in xrange ( 1 , 25 , 2 ): ... res . append ( x ) ... >>> print res В общем-то, полученный результат — целиком нас устраивает всем, кроме длинной записи. тут-то на помощь и придет наш «сахарок». В самом простом виде, он обычно >>> res = [ x for x in xrange ( 1 , 25 , 2 )] >>> print res [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 ] В общем виде эта конструкция такова: python [stmt for var in iterable if predicate] По-мимо генератора списка есть синтаксический сахар - генератор словарей.","tags":"Синтаксис Python","title":"Генераторы списков","url":"http://pynsk.ru/posts/2015/июля/20/generatory-spiskov/"},{"text":"Видео с конференции PyCon В видео докладчик рассказал о плюсах Python. О тех самых преимуществах, которые не надо обходить стороной. !function(a){ var b=\"embedly-platform\",c=\"script\"; if(!a.getElementById(b)){ var d=a.createElement(c); d.id=b; d.src=(\"https:\"===document.location.protocol?\"https\":\"http\")+\"://cdn.embedly.com/widgets/platform.js\"; var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)} }(document);","tags":"Разное","title":"Почему Python клёвый?","url":"http://pynsk.ru/posts/2015/июля/20/pochemu-python-kliovyi/"}]}