<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyNSK - Новосибирское Python сообщество</title><link>http://pynsk.ru/</link><description></description><atom:link href="http://pynsk.ru/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 09 Nov 2015 18:00:00 +0600</lastBuildDate><item><title>Математика в Python: Преобразование фурье</title><link>http://pynsk.ru/posts/2015/%D0%BD%D0%BE%D1%8F%D0%B1./09/matematika-v-python-preobrazovanie-fure/</link><description>&lt;p&gt;Осторожно, МАТАН!!!&lt;/p&gt;
&lt;p&gt;По-простому, &lt;strong&gt;преобразование Фурье&lt;/strong&gt; — разложение некоторого сигнала на гармонические (синусы или косинусы) колебания (спектр). &lt;/p&gt;
&lt;p&gt;Если вы осознанно употребляете слово "частота", вы уже хотя бы интуитивно представляете, что такое преобразование Фурье. Даже в наших ушах есть хардверный анализатор Фурье (улитка) (а также продвинутые драйвера в мозгу), благодаря которому мы различаем голоса, ноты, тембры... Призма раскладывает белый свет на цвета радуги — это тоже Фурье-анализатор. Форматы mp3 и jpeg в своих алгоритмах содержат преобразование Фурье (одномерное и двухмерное, соответственно) для сжатия информации. В природе и технике есть тысячи примеров... Также есть обратное преобразование Фурье, переводящее "частоты" и "амплитуды" в "сигнал", математически очень похожее на прямое.&lt;/p&gt;
&lt;p&gt;Преобразование Фурье является &lt;strong&gt;интегральным преобразованием&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;Если речь идёт о дискретном сигнале, то интеграл обращается в сумму (и становится &lt;code&gt;дискретным преобразованием Фурье, ДПФ&lt;/code&gt;). Беда в том, что, чтобы посчитать такую сумму &lt;code&gt;N&lt;/code&gt; элементов, надо совершить &lt;code&gt;N^2&lt;/code&gt; операций с комплексными числами. Но кто-то очень умный давно (&lt;code&gt;Cooley, Tukey, 1965 г&lt;/code&gt;, а ещё сам &lt;code&gt;Гаусс в 1805 г.&lt;/code&gt;) придумал алгоритм, вычисляющий &lt;code&gt;ДПФ&lt;/code&gt; &lt;code&gt;N&lt;/code&gt; элементов в &lt;code&gt;N*log(N)&lt;/code&gt; операций (большая часть из которых над действительными числами), что существенно экономит вычислительное время — быстрое преобразование Фурье, БПФ (&lt;code&gt;Fast Fourier Transform, FFT&lt;/code&gt;). Именно так реализовано ДПФ в современных компьютерных программах.&lt;/p&gt;
&lt;p&gt;В библиотеке &lt;code&gt;numpy&lt;/code&gt; содержится всё что нужно для дискретного преобразования Фурье. Всё это лежит в &lt;code&gt;numpy.fft&lt;/code&gt;. Вот эти функции.&lt;/p&gt;
&lt;p&gt;Общий случай: сигнал может быть как из действительных чисел, так и из комплексных.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fft(a, n=None, axis=-1) — прямое одномерное ДПФ.
ifft(a, n=None, axis=-1) — обратное одномерное ДПФ.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;a&lt;/code&gt; — "сигнал", входной массив (массив &lt;code&gt;numpy&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt; или даже питоновский &lt;code&gt;список&lt;/code&gt; или &lt;code&gt;кортеж&lt;/code&gt;, если в нём только числа). Массив может быть и многомерным, тогда будет вычисляться много &lt;code&gt;ОДНОМЕРНЫХ ПФ&lt;/code&gt; по строкам (по умолчанию) или столбцам, в зависимости от параметра axis. Например, &lt;code&gt;a&lt;/code&gt; — двухмерный, &lt;code&gt;a[n][m]&lt;/code&gt;: при &lt;code&gt;axis=1&lt;/code&gt; или &lt;code&gt;-1&lt;/code&gt; будет такое (под &lt;code&gt;fourier(a...)&lt;/code&gt; понимается результат действия ПФ на &lt;code&gt;a&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[fourier(a[0][j]), fourier(a[1][j]), ... foirier(a[n][j])]&lt;/span&gt;
&lt;span class="na"&gt;При axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0 такое:&lt;/span&gt;
&lt;span class="k"&gt;[fourier(a[i][0]), fourier(a[i][1]), ... foirier(a[i][m])]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;n&lt;/code&gt; — сколько элементов массива брать. Если меньше длины массива, то обрезать, если больше, то дополнить нулями, по умолчанию &lt;code&gt;len(a)&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fft2(a, s=None, axes=(-2, -1)) — прямое двухмерное ПФ.
ifft2(a, s=None, axes=(-2, -1)) — обратное двухмерное ПФ.
fftn(a, s=None, axes=None) — прямое многомерное ПФ.
ifftn(a, s=None, axes=None) — обратное многомерное ПФ.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Всё так же, как и для одномерных, но s и axes теперь кортежи для каждой размерности. О размерности &lt;code&gt;fftn&lt;/code&gt;, &lt;code&gt;ifftn&lt;/code&gt; догадаются по размерности входных массивов или &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;axes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Когда сигнал действительный (&lt;code&gt;real&lt;/code&gt;) (пожалуй, самый распространённый случай).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rfft(a, n=None, axis=-1) — прямое одномерное ДПФ (для действительных чисел).
irfft(a, n=None, axis=-1) — обратное одномерное ДПФ.
rfft2(a, s=None, axes=(-2, -1)) — прямое двухмерное ДПФ.
irfft2(a, s=None, axes=(-2, -1)) — обратное двухмерное ДПФ.
rfftn(a, s=None, axes=None) — прямое многомерное ДПФ.
irfftn(a, s=None, axes=None) — обратное многомерное ДПФ.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Всё так же, как и для общего случая.&lt;/p&gt;
&lt;p&gt;Все эти функции возвращают массив соответствующей размерности, в котором записан результат &lt;code&gt;ДПФ&lt;/code&gt;. &lt;em&gt;Разница такая&lt;/em&gt;. Если длина входного массива (или какой-либо его размерности) &lt;code&gt;N&lt;/code&gt;, то в общем случае (с комплексным сигналом) длина выходного массива &lt;code&gt;N&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Там содержатся сначала положительные частоты от нуля до частоты Котельникова (Найквиста), потом отрицательные в порядке возрастания.&lt;/p&gt;
&lt;p&gt;В случае действительного сигнала отрицательные частоты полностью симметричны положительным, и тогда нет нужды их записывать: длина выходного массива &lt;code&gt;N/2+1&lt;/code&gt;, частоты от нуля до частоты Котельникова.&lt;/p&gt;
&lt;p&gt;Если спектр сигнала действительный (а сигнал обладает "эрмитовой симметрией": его половины симметричны относительно центра по модулю и являются комплексно сопряжёнными друг другу), то можно применить такие функции:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;hfft(a, n=None, axis=-1) — прямое одномерное ДПФ.
ihfft(a, n=None, axis=-1) — обратное одномерное ДПФ.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Длина входного массива &lt;code&gt;N&lt;/code&gt;, а выходного &lt;code&gt;2*N+1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Кроме того, есть вспомогательные функции (будет понятнее из примера):
fftfreq(n, d=1.0) — возвращает частоты для выходных массивов функций fft&lt;em&gt;.
rfftfreq(n, d=1.0) — возвращает частоты для выходных массивов функций rfft&lt;/em&gt;.
n — длина входного массива, d — период дискретизации (обратная частота дискретизации).
fftshift(x, axes=None) — преобразует массив (с результатом ДПФ, от функций fft*) так, чтобы нулевая частота была в центре.
ifftshift(x, axes=None) — делает обратную операцию.&lt;/p&gt;
&lt;p&gt;Приведём такой пример. Допустим, записали мы микрофоном какой-то шум, и надо определить, есть ли там какой-нибудь тон.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;#coding=utf8&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;np_abs&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;numpy.fft&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;rfft&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rfftfreq&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;numpy.random&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;uniform&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;
&lt;span class="c"&gt;# а можно импортировать numpy и писать: numpy.fft.rfft&lt;/span&gt;
&lt;span class="n"&gt;FD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22050&lt;/span&gt; &lt;span class="c"&gt;# частота дискретизации, отсчётов в секунду&lt;/span&gt;
&lt;span class="c"&gt;# а это значит, что в дискретном сигнале представлены частоты от нуля до 11025 Гц (это и есть теорема Котельникова)&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt; &lt;span class="c"&gt;# длина входного массива, 0.091 секунд при такой частоте дискретизации&lt;/span&gt;
&lt;span class="c"&gt;# сгенерируем сигнал с частотой 440 Гц длиной N&lt;/span&gt;
&lt;span class="n"&gt;pure_sig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mf"&gt;6.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;440.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;FD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
&lt;span class="c"&gt;# сгенерируем шум, тоже длиной N (это важно!)&lt;/span&gt;
&lt;span class="n"&gt;noise&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;uniform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;50.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;50.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# суммируем их и добавим постоянную составляющую 2 мВ (допустим, не очень хороший микрофон попался. Или звуковая карта или АЦП)&lt;/span&gt;
&lt;span class="n"&gt;sig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure_sig&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;noise&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt; &lt;span class="c"&gt;# в numpy так перегружена функция сложения&lt;/span&gt;
&lt;span class="c"&gt;# вычисляем преобразование Фурье. Сигнал действительный, поэтому надо использовать rfft, это быстрее, чем fft&lt;/span&gt;
&lt;span class="n"&gt;spectrum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rfft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# нарисуем всё это, используя matplotlib&lt;/span&gt;
&lt;span class="c"&gt;# Сначала сигнал зашумлённый и тон отдельно&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FD&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# по оси времени секунды!&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FD&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;pure_sig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# чистый сигнал будет нарисован красным&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Время, c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# это всё запускалось в Python 2.7, поэтому юникодовские строки&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Напряжение, мВ&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Зашумлённый сигнал и тон 440 Гц&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;# когда закроется этот график, откроется следующий&lt;/span&gt;
&lt;span class="c"&gt;# Потом спектр&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfftfreq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;FD&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np_abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spectrum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# rfftfreq сделает всю работу по преобразованию номеров элементов массива в герцы&lt;/span&gt;
&lt;span class="c"&gt;# нас интересует только спектр амплитуд, поэтому используем abs из numpy (действует на массивы поэлементно)&lt;/span&gt;
&lt;span class="c"&gt;# делим на число элементов, чтобы амплитуды были в милливольтах, а не в суммах Фурье. Проверить просто — постоянные составляющие должны совпадать в сгенерированном сигнале и в спектре&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Частота, Гц&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Напряжение, мВ&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Спектр&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки для изучения:
- &lt;a href="https://ru.wikipedia.org/wiki/Преобразование_Фурье"&gt;Преобразование Фурье&lt;/a&gt;
- &lt;a href="https://ru.wikipedia.org/wiki/Быстрое_преобразование_Фурье"&gt;Быстрое преобразование Фурье&lt;/a&gt;
- &lt;a href="https://ru.wikipedia.org/wiki/Дискретное_преобразование_Фурье"&gt;Дискретное преобразование Фурье&lt;/a&gt;
- &lt;a href="https://ru.wikipedia.org/wiki/Теорема_Котельникова"&gt;Теорема Котельникова&lt;/a&gt;
- &lt;a href="http://habrahabr.ru/post/196374/"&gt;Простыми словами о преобразовании Фурье&lt;/a&gt;
- &lt;a href="http://habrahabr.ru/post/269991/"&gt;Практическое применение преобразования Фурье для анализа сигналов. Введение для начинающих&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 09 Nov 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-11-09:posts/2015/нояб./09/matematika-v-python-preobrazovanie-fure/</guid><category>матан</category></item><item><title>Анонс встречи №4 сообщества PyNSK</title><link>http://pynsk.ru/posts/2015/%D0%BD%D0%BE%D1%8F%D0%B1./05/anons-vstrechi-4-soobshchestva-pynsk/</link><description>&lt;p&gt;&lt;img alt="Image" src="http://pynsk.ru/images/event/event_4.png" /&gt;&lt;/p&gt;
&lt;p&gt;Встреча сообщества PyNSK состоится 15 ноября (воскресенье) в 13 часов, в Самоваре (&lt;a href="http://go.2gis.com/b20p"&gt;http://go.2gis.com/b20p&lt;/a&gt;)
Регистрация на встречу по ссылке - &lt;a href="http://bit.ly/pynsk4_reg"&gt;http://bit.ly/pynsk4_reg&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;На встрече вас ожидает море общения и три доклада:&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Владимир Донец (kwimba.ru, https://vk.com/vovk.donets)&lt;/strong&gt; расскажет доклад &lt;strong&gt;"Магия в Python: Дескрипторы. Что это?"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Описание:&lt;/strong&gt; Слышали про магию в Python? Одно из магических заклинаний называется дескрипторы. Мощная фича языка, которая позволяет определять свое поведение атрибута объекта при доступе к этому атрибуту. 
Сложно звучит? А вы знали, что дескрипторами уже наверняка пользовались, если хотя бы раз писали на Python. Я расскажу о том, что такое дескрипторы и как их осознанно можно применять в собственном коде. Так что приходите. Наверняка будут чай, кофе, печеньки и дружеские рукопожатия&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Богомолов Иван&lt;/strong&gt; с мини-докладом расскажет как начать работать с Google API - &lt;strong&gt;"Быстрый старт в gDrive API"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Описание:&lt;/strong&gt; Краткий обзор разных вариантов использования gDrive API, так же вы узнаете как получить доступ к gDrive API, конечно же с примерами подключения, авторизации и выполнения различных запросов на питоне.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Александр Маршалов (ЦФТ, https://vk.com/alone.amper)&lt;/strong&gt; расскажет про AST с докладом: &lt;strong&gt;"Модифицируй это!" или "Больше магии Python с помощью изменения AST"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Описание:&lt;/strong&gt; Мы узнаем, что из себя представляет дерево синтаксического разбора (AST / Abstract Syntax Tree) в языке Python 
и какие магические возможности можно получить с помощью модификации AST.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 05 Nov 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-11-05:posts/2015/нояб./05/anons-vstrechi-4-soobshchestva-pynsk/</guid></item><item><title>Hardcore Python: Оптимизация на грани и за ней</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./30/hardcore-python-optimizatsiia-na-grani-i-za-nei/</link><description>&lt;p&gt;Возможно, вы видели доклад Антона Патрушева про оптимизацию Python — вплоть до отключения Garbage Collector.
Это свежий доклад (PyCon RU 2015) и в нём вы найдете развитие идей оптимизации Python&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/c0qb9-8s5IU?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 30 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-30:posts/2015/окт./30/hardcore-python-optimizatsiia-na-grani-i-za-nei/</guid><category>оптимизация</category><category>gc</category><category>garbage collector</category><category>видео</category></item><item><title>Hardcore Python: Пишем свой интерпретатор</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./29/hardcore-python-pishem-svoi-interpretator/</link><description>&lt;p&gt;Говорят, что отличный результат для мужчины — построить дом, вырастить сына и посадить дерево. А если ты программист, то ещё написать свой язык программирования.&lt;/p&gt;
&lt;p&gt;Сейчас уже нет чисто интерпретируемых языков, даже Python сначала компилируется в байт-код, а потом интерпретируется — исполняется. 
Но как это он делает?&lt;/p&gt;
&lt;p&gt;Чтобы узнать магию внутренностей интерпретаторов предлагаю цикл статей Let’s Build A Simple Interpreter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ruslanspivak.com/lsbasi-part1/"&gt;http://ruslanspivak.com/lsbasi-part1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ruslanspivak.com/lsbasi-part2/"&gt;http://ruslanspivak.com/lsbasi-part2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ruslanspivak.com/lsbasi-part3/"&gt;http://ruslanspivak.com/lsbasi-part3/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ruslanspivak.com/lsbasi-part4/"&gt;http://ruslanspivak.com/lsbasi-part4/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ruslanspivak.com/lsbasi-part5/"&gt;http://ruslanspivak.com/lsbasi-part5/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 29 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-29:posts/2015/окт./29/hardcore-python-pishem-svoi-interpretator/</guid><category>интерпретатор</category></item><item><title>Пишем web-проекты: Использование gevent для эмуляции высокой нагрузки</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./29/pishem-web-proekty-ispolzovanie-gevent-dlia-emuliatsii-vysokoi-nagruzki/</link><description>&lt;p&gt;Обязательное действие перед выпуском более-менее серьёзного проекта — тестирование производительности. На высоконагруженных проектах нужно точно знать, какую нагрузку они могут выдержать, причём заранее. Следовательно, нужен способ эмуляции высокой конкурентности, желательно чтобы в теории он позволял полностью загрузить канал траффиком. К тому же, неплохо было бы, чтобы для этого не нужно было использовать несколько десятков серверов. В докладе будет рассказано об опыте использования gevent для подобной задачи, что позволило бы обойтись одним t1.micro инстансом, с которого выполняется тестирование.&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/ndngDDiGaFw?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 29 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-29:posts/2015/окт./29/pishem-web-proekty-ispolzovanie-gevent-dlia-emuliatsii-vysokoi-nagruzki/</guid><category>видео</category><category>gevent</category></item><item><title>Пишем web-проекты: Погружение в полнотекстовый поиск, используя Python</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./28/pishem-web-proekty-pogruzhenie-v-polnotekstovyi-poisk-ispolzuia-python/</link><description>&lt;p&gt;Чем больше/непонятней сайт, тем чаще используют поиск. В докладе Андрея Солдатенко вы сможете узнать как организовать хороший поиск по вашему сайту &lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/vXl7EEURfO8?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 28 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-28:posts/2015/окт./28/pishem-web-proekty-pogruzhenie-v-polnotekstovyi-poisk-ispolzuia-python/</guid><category>видео</category></item><item><title>Учебные материалы: Куда ползёт питон?</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./27/uchebnye-materialy-kuda-polziot-piton/</link><description>&lt;p&gt;Чем Python и его экосистема отличается от других языков программирования? Какая у Python ниша? Какие сильные и слабые стороны у языка и батареек? На все эти вопросы Григорий попробует ответить в своём обзорном докладе, рассказывающем о том, куда ползёт Python в 2015 году&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/_79KfX-3sQc?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 27 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-27:posts/2015/окт./27/uchebnye-materialy-kuda-polziot-piton/</guid><category>видео</category></item><item><title>Синтаксис Python: raw-unicode-escape против u'\xd0\x9a'</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./26/sintaksis-python-raw-unicode-escape-protiv-uxd0x9a/</link><description>&lt;p&gt;Python 2 и проблемы с кодировками — это единое целое. И мало, что сами файлы с исходниками сохраняют в самых разных кодировках, так и текстовые файлы с данными этим грешат.
Казалось бы, используй &lt;code&gt;encode/decode&lt;/code&gt; и что тут думать. Но бывает, что декодируешь юникод и получаешь строку:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;u&amp;#39;\xd0\x9a\xd1\x83\xd1\x80\xd1\x83\xd0\xbc\xd0\xbe\xd1\x87&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Юникодные символы в юникодной строке. И вот здесь гугл начинает молить о пощаде, предлагая вариант — составить словарь символов и букв и сделать replace.&lt;/p&gt;
&lt;p&gt;Но есть и более удобный вариант — кодек &lt;code&gt;'raw-unicode-escape'&lt;/code&gt;.
И тогда, использование выглядит так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xd0\x9a\xd1\x83\xd1\x80\xd1\x83\xd0\xbc\xd0\xbe\xd1\x87&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;raw-unicode-escape&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;Курумоч&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 26 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-26:posts/2015/окт./26/sintaksis-python-raw-unicode-escape-protiv-uxd0x9a/</guid><category>кодировка</category><category>encoding</category><category>юникод</category><category>unicode</category></item><item><title>Математика в Python: Матрицы в NumPy</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./25/matematika-v-python-matritsy-v-numpy/</link><description>&lt;p&gt;Списки - встроенный тип Python, могут содержать любые элементы: целые, дробные числа, строки, объекты. Это великая сила Python, но в то же время и слабость — в отношении скорости работы. &lt;/p&gt;
&lt;p&gt;В стандартные дистрибутивы Python входит модуль array, реализующий аналог массивов C/C++, он может пригодиться для простейших расчётов с многомерными массивами, матрицами.&lt;/p&gt;
&lt;p&gt;NumPy — мощнейшая библиотека для научных вычислений. Написать здесь операции с матрицами так же просто, как и с обычными числами. &lt;/p&gt;
&lt;p&gt;Матрица в NumPy — это объект numpy.array, массив чисел одного типа, какой угодно размерности: 0 (одно число, скаляр), 1 (вектор), 2 (матрица), 3 (тензор третьего ранга)... &lt;/p&gt;
&lt;p&gt;Матрицы во многом похожи на списки и массивы модуля array: поддерживают индексацию с таким же синтаксисом и легко преобразуются в них.&lt;/p&gt;
&lt;p&gt;Перейдём к делу. Например, нужно посчитать произведение и сумму матриц, скаляров и векторов. Мы бы на бумаге записали так:&lt;/p&gt;
&lt;p&gt;A&lt;em&gt;B&lt;/em&gt;C*D + E,
где B,C — матрицы 2x2, D,E — вектор-столбцы, A — скаляр (число).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt; &lt;span class="c"&gt;# обычное число&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;# а можно и так&lt;/span&gt;

&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diag&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mf"&gt;1.32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.78&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c"&gt;# треугольная, матрица, делаем диагональную матрицу&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.12&lt;/span&gt; &lt;span class="c"&gt;# потом дописываем элемент B_12 (обозначение, как мы привыкли в институтах)&lt;/span&gt;

&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c"&gt;# сначала делаем вектор-строку и заполняем нулями,&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;concatenate&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;­&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt; &lt;span class="c"&gt;# добавляем внизу вектор-строку (3, 2)&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.97&lt;/span&gt; &lt;span class="c"&gt;# и для интереса сделаем элемент (1,1) ненулевым&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="c"&gt;# а теперь транспонируем, тоже для интереса&lt;/span&gt;

&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# просто делаем вектор-столбец с дробными числами,&lt;/span&gt;
&lt;span class="c"&gt;# а точки писать лень (но и без dtype вычисления будут дробные, так как дробные числа уже есть)&lt;/span&gt;

&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# вектор-столбец из единиц&lt;/span&gt;
&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mf"&gt;2.3&lt;/span&gt; &lt;span class="c"&gt;# домножим для интереса&lt;/span&gt;

&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="c"&gt;# проще пареной репы!!!&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Результат:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;­&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;1.32&lt;/span&gt; &lt;span class="mf"&gt;3.12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;0.&lt;/span&gt; &lt;span class="mf"&gt;0.78&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;­&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;0.97&lt;/span&gt; &lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;0.&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;10.&lt;/span&gt; &lt;span class="mf"&gt;12.&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;­&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;2.3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;2.3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;­&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;21.506&lt;/span&gt; &lt;span class="mf"&gt;170.78&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mf"&gt;2.3&lt;/span&gt; &lt;span class="mf"&gt;30.38&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Мораль: &lt;/p&gt;
&lt;p&gt;производить действия с матрицами в NumPy так же просто, как и при рисовании их символов в тетради на парах линейной алгебры. 
Пусть этот пример выглядит наивным, но он показывает, что есть множество инструментов для конструирования матриц, не говоря уже о банальной инициализации известными элементами. &lt;/p&gt;
&lt;p&gt;А если речь идёт о матрицах 10x10? Трёхмерных, четырёхмерных? С комплексными числами? И даже с произвольными объектами вместо чисел (если определить арифметические действия над ними)? &lt;/p&gt;
&lt;p&gt;NumPy Вам в помощь.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 25 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-25:posts/2015/окт./25/matematika-v-python-matritsy-v-numpy/</guid><category>numpy</category></item><item><title>Таинство стандартной библиотеки: timeit - измерим время работы!</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./25/tainstvo-standartnoi-biblioteki-timeit-izmerim-vremia-raboty/</link><description>&lt;p&gt;Представим мы придумали алгоритм, на пальцах оценили его быстродействие, закодили и получили медленно работающий софт.
Что делать? куда бежать? С чего стоит начать?
Да сначала стоит измерить сколько &lt;em&gt;ресурсов&lt;/em&gt; (память, время, проц) кушает ваш софт. Уже имея числа на руках можно думать дальше.&lt;/p&gt;
&lt;p&gt;Для измерения временных затрат для вашего кода можно воспользоваться библиотекой &lt;code&gt;timeit&lt;/code&gt;. А другие ресурсы измерим в след. раз.
Она позволяет измерить время работы куска кода программы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;timeit&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;quot;-&amp;quot;.join(str(n) for n in range(100))&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mf"&gt;0.3018611848820001&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;quot;-&amp;quot;.join([str(n) for n in range(100)])&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mf"&gt;0.2727368790656328&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;quot;-&amp;quot;.join(map(str, range(100)))&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mf"&gt;0.23702679807320237&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылка для изучения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.4/library/timeit.html"&gt;https://docs.python.org/3.4/library/timeit.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 25 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-25:posts/2015/окт./25/tainstvo-standartnoi-biblioteki-timeit-izmerim-vremia-raboty/</guid><category>time</category><category>timeit</category><category>измерение</category><category>время</category><category>быстродействие</category><category>производительность</category></item><item><title>Таинство стандартной библиотеки: zipimport - импортируем код из zip файлов</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./24/tainstvo-standartnoi-biblioteki-zipimport-importiruem-kod-iz-zip-failov/</link><description>&lt;p&gt;Еще в далеком Python 2.3 был добавлен модуль &lt;code&gt;zipimport&lt;/code&gt;. 
Этот модуль упростил возможность импорта из &lt;code&gt;zip&lt;/code&gt; файлов: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;python&lt;/span&gt;
&lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="mf"&gt;2.3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="c"&gt;#1, Aug 1 2003, 19:54:32) &lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/tmp/example.zip&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# Add .zip file to front of path&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;jwzthreading&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;jwzthreading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;/tmp/example.zip/jwzthreading.py&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(больше примеров по см. по первой ссылке)&lt;/p&gt;
&lt;p&gt;Конечно, такой функционал мало кому нужен, но давайте придумаем какой-то use-case - пофантазируем. Пишите свои мысли в комментариях&lt;/p&gt;
&lt;p&gt;Предположим что есть динамическая система, какая-то жутко настраиваемая система - в зависимости от дня недели выполняется код. Тогда можно реализовать в коде выкачивание нужного архива с вашего сервера в виде zip файла и затем с помощью zipimport исполнять код.&lt;/p&gt;
&lt;p&gt;Ссылки: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/zipimport/"&gt;https://pymotw.com/2/zipimport/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/zipimport.html"&gt;https://docs.python.org/2/library/zipimport.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2.3/whatsnew/node5.html"&gt;https://docs.python.org/2.3/whatsnew/node5.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/company/acronis/blog/208378/"&gt;http://habrahabr.ru/company/acronis/blog/208378/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 24 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-24:posts/2015/окт./24/tainstvo-standartnoi-biblioteki-zipimport-importiruem-kod-iz-zip-failov/</guid><category>zip</category><category>import</category></item><item><title>Синтаксис Python: слайсы/срезы</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./19/sintaksis-python-slaisysrezy/</link><description>&lt;p&gt;Синтаксис Python легкий, читаемый. 
Хочется упомянуть массивы (как структура с последовательными элементами). В Python они бывают разные - &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, строки
Операции с массивами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Получить копию&lt;/li&gt;
&lt;li&gt;Получить первые/последние N элементов&lt;/li&gt;
&lt;li&gt;Получить N элементом с позиции M&lt;/li&gt;
&lt;li&gt;Получить каждый N элемент&lt;/li&gt;
&lt;li&gt;Развернуть &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Все эти операции и их комбинации отлично выполняются оператором &lt;code&gt;[]&lt;/code&gt; - метод &lt;code&gt;__getitem__&lt;/code&gt;
Для примера:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#простой список&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt; &lt;span class="c"&gt;#копия списка, часто очень полезно&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="c"&gt;# все элементы кроме первого&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="c"&gt;# последние 3 элемента&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#откидываем первые и последние 2&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#парные элементы&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;#элементы с первого по четвертый с шагом 2&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Очень подробная статья с примерами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/89456/"&gt;http://habrahabr.ru/post/89456/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 19 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-19:posts/2015/окт./19/sintaksis-python-slaisysrezy/</guid><category>слайс</category><category>срез</category><category>список</category><category>list</category><category>slice</category></item><item><title>Синтаксис Python: переменная __all__</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./19/sintaksis-python-peremennaia-__all__/</link><description>&lt;p&gt;Вы наверное слышали фразу "wild import - зло". В коде это выглядит так&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;my_super_module&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ответ почему это "зло" очень простой - вы импортируете всё - то что надо и то что не надо. А значит вы можете смело перегрузить какой-то метод. 
Как же быть? Можно импортировать только нужные переменные и функции/классы, что является правильным подходом. Но ведь должен быть альтернативный вариант.&lt;/p&gt;
&lt;p&gt;Он есть - это переменная &lt;code&gt;__all__&lt;/code&gt;
&lt;code&gt;__all__&lt;/code&gt; в Pythone - это список публичных объектов данного модуля.&lt;/p&gt;
&lt;p&gt;Например, есть некий &lt;code&gt;mymodule.py&lt;/code&gt;, в нем очень много объектов, и не требуется давать пользоваться ими всеми (например, какие-то приватные функции есть). В &lt;code&gt;__all__&lt;/code&gt; в &lt;code&gt;mymodule.py&lt;/code&gt; вы списком определяете названия объектов, которые можно импортировать:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;MyClass&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MyClass2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;И тогда конструкция&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;mymodule&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Импортирует только те объекты, которые вы описали в &lt;code&gt;__all__&lt;/code&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 19 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-19:posts/2015/окт./19/sintaksis-python-peremennaia-__all__/</guid><category>синтаксис</category><category>магическая переменная</category><category>__all__</category></item><item><title>Учебные материалы: сборник ООП паттернов</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./17/uchebnye-materialy-sbornik-oop-patternov/</link><description>&lt;p&gt;ООП преподают везде. В школе, в универе, в колледже, на курсах, упоминают в статьях, есть даже много книг на эту тему - например, банда четырех.
Важным моментом ОО это паттерны. Это набор узаконенных хитростей и хаков, которые позволяют обходить недостатки самого ООП. 
По ссылке &lt;a href="https://github.com/faif/python-patterns"&gt;https://github.com/faif/python-patterns&lt;/a&gt;  вы сможете найти готовый код для множества паттернов.&lt;/p&gt;
&lt;p&gt;А как вы считаете, где ООП устапает ФП (функциональному программированию), а где превосходит?&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 17 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-17:posts/2015/окт./17/uchebnye-materialy-sbornik-oop-patternov/</guid><category>паттер</category><category>ооп</category><category>сборник</category></item><item><title>Hardcore Python: как PyPy запускает твой код</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./16/hardcore-python-kak-pypy-zapuskaet-tvoi-kod/</link><description>&lt;p&gt;PyPy - интерпретатор Python написанный на Python. 
Прелесть PyPy что он работает быстрее чем стандартный Python. В этом видео вы сможете узнать за счет чего это происходит&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/mHTu723RDNI?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 16 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-16:posts/2015/окт./16/hardcore-python-kak-pypy-zapuskaet-tvoi-kod/</guid><category>pypy</category><category>видео</category></item><item><title>Опыт разработчиков: использование переменной _</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./16/opyt-razrabotchikov-ispolzovanie-peremennoi-_/</link><description>&lt;p&gt;Хорошие имена переменных - это признак хорошего кода. 
Для циклов часто используют одно-буквенные переменные, для временных переменных тоже короткие, для глобальных - ЗАГЛАВНЫЕ. Есть и другие рекомендации. Все они написаны кровью из глаз разработчиков.&lt;/p&gt;
&lt;p&gt;Перейдем к заголовку и сразу пример:
Пускай есть функция, которая возвращает 3 значения.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;super_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;....&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Функция возвращает три значения, а нам в данном кусе кода необходимо только 2, а может одно? Пускай среднее. Куда "потерять" первую и третью переменную?&lt;/p&gt;
&lt;p&gt;В этом случае может однобуквенная переменная &lt;code&gt;_&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;super_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Что произошло? Мы сохранили среднее значение в переменную value, а два других в _.&lt;br /&gt;
Переменная с названием _ это такая же как и value, ничем не примечательна кроме названия. Оно как бы пустое, очень короткое, мало внимания привлекает. Рекомендуем использовать для значений, которые используются единожды в коде.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 16 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-16:posts/2015/окт./16/opyt-razrabotchikov-ispolzovanie-peremennoi-_/</guid><category>опыт</category></item><item><title>Таинство стандартной библиотеки: сериализуем данные с помощью marshal</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./14/tainstvo-standartnoi-biblioteki-serializuem-dannye-s-pomoshchiu-marshal/</link><description>&lt;p&gt;Наверное, вы слышали про модуль Pickle, который умеет сериализовать объект в бинарный вид, который можно потом сохранить/загрузить в /из файл.&lt;/p&gt;
&lt;p&gt;А модуль marshal сериализует объект в текстовый вид.
Получив строку вы можете отправить ее другу по email, а уже из строки снова получить объект&lt;/p&gt;
&lt;p&gt;Особенности модуля:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Данные сохраняются в платформонезависимом формате.&lt;/li&gt;
&lt;li&gt;Поддерживаются только None, целые числа, длинные целые числа, числа с плавающей точкой, комплексные числа, строки, строки Юникода, кортежи, списки, словари и объекты с программным кодом. Списки, кортежи и словари могут содержать только объекты поддерживаемых типов. Экземпляры классов и рекурсивные ссылки в списках, кортежах и словарях не поддерживаются.&lt;/li&gt;
&lt;li&gt;Модуль marshal не обеспечивает защиту от ошибочных или злонамеренных данных и не должен использоваться для чтения данных, полученных из непроверенных источников.&lt;/li&gt;
&lt;li&gt;Модуль marshal имеет значительно более высокую производительность, чем модуль pickle, и имеет менее широкие возможности.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 14 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-14:posts/2015/окт./14/tainstvo-standartnoi-biblioteki-serializuem-dannye-s-pomoshchiu-marshal/</guid><category>marshal</category><category>pickle</category></item><item><title>Интересные концепции: fuzzy-testing - тестирование грубой силой</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./13/interesnye-kontseptsii-fuzzy-testing-testirovanie-gruboi-siloi/</link><description>&lt;p&gt;Тестирование программ повышает уверенность в ее способности работать. Есть даже большие школы, которые говорят о тестах, например, TDD, BDD.&lt;/p&gt;
&lt;p&gt;У ручных тестов есть недостаток, среди прочих - тесты пишет человек. В следствии этого - он не сможет проверить работу функции/класса/etc на всех данных. А когда нам быть уверенным что даже на самых невалидных данных работает корректно, то без случайных данных не обойтись.&lt;/p&gt;
&lt;p&gt;fuzz-testing (Фаззинг) – методика тестирования, при которой на вход программы подаются невалидные, непредусмотренные или случайные данные.&lt;/p&gt;
&lt;p&gt;Фаззинг позволяет расширить количество проверок за счет автоматической генерации данных. От сюда и вытекают недостатки - скорость прохождения тестов падает, есть большие сложности с генерацией сложных данных. Тяжело посчитать процент покрытия кода. Тяжело воспроизводить неправильные проходы тестов.&lt;/p&gt;
&lt;p&gt;Инструментов, которые по принципу xUnit - две строчки написал и работает тест - для фаззинга нет. Или автор ошибается? Подскажите в комментариях&lt;/p&gt;
&lt;p&gt;Ссылки: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/128503/"&gt;http://habrahabr.ru/post/128503/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/library/j-fuzztest/"&gt;https://www.ibm.com/developerworks/library/j-fuzztest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 13 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-13:posts/2015/окт./13/interesnye-kontseptsii-fuzzy-testing-testirovanie-gruboi-siloi/</guid><category>тест</category><category>fuzzy-testing</category><category>fuzzy</category><category>testing</category></item><item><title>Полезные инструменты: fabric - автоматизируем рутину</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./13/poleznye-instrumenty-fabric-avtomatiziruem-rutinu/</link><description>&lt;p&gt;Ситуация: написали web-проект, свой, домашний, а может и на работе. Надо его опубликовать в Интернет - задеплоить. 
Зашли на сервер, активировали venv, скачали новые исходники из репозитория, накатили миграции, обновили static-файлы, перезапустили, предположим, celery, перезапустили uwsgi.&lt;/p&gt;
&lt;p&gt;И тут, поняли что забыли раскоментировать строчку в коде. Делаем коммит, снова заходим на сервер, активировали venv.... 
Зачем вся эта рутина с деплоем? Может есть способ проще? Мы же IT-шники, давайте напишем скрипт. &lt;/p&gt;
&lt;p&gt;Здесь то на помощь и приходит &lt;code&gt;fabric&lt;/code&gt; - инструмент командной строки. 
&lt;code&gt;fabric&lt;/code&gt; предоставляет обертку над командной строкой. Вы пишите fab файл с вашим сценарием деплоя. Например.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fabric.api&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;host_type&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;uname -s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;А затем запускаете на нескольких (или одной) удаленной машине&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;fab -H localhost,linuxbox host_type
&lt;span class="o"&gt;[&lt;/span&gt;localhost&lt;span class="o"&gt;]&lt;/span&gt; run: uname -s
&lt;span class="o"&gt;[&lt;/span&gt;localhost&lt;span class="o"&gt;]&lt;/span&gt; out: Darwin
&lt;span class="o"&gt;[&lt;/span&gt;linuxbox&lt;span class="o"&gt;]&lt;/span&gt; run: uname -s
&lt;span class="o"&gt;[&lt;/span&gt;linuxbox&lt;span class="o"&gt;]&lt;/span&gt; out: Linux

Done.
Disconnecting from localhost... &lt;span class="k"&gt;done&lt;/span&gt;.
Disconnecting from linuxbox... &lt;span class="k"&gt;done&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Все очень просто&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fabfile.org/"&gt;http://www.fabfile.org/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 13 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-13:posts/2015/окт./13/poleznye-instrumenty-fabric-avtomatiziruem-rutinu/</guid><category>fabric</category><category>автоматизация</category><category>инструмент</category></item><item><title>Интересные концепции: какой смысл с Объектном подходе?</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./12/interesnye-kontseptsii-kakoi-smysl-s-obektnom-podkhode/</link><description>&lt;p&gt;В Интернет часто говорят об ООП, об объектах. Так какой смысл во всем этом? Какая польза, недостатки?
Соображения на эту темы вы сможете найти в видео:&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/M1XL65qj2dU?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 12 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-12:posts/2015/окт./12/interesnye-kontseptsii-kakoi-smysl-s-obektnom-podkhode/</guid><category>видео</category><category>объект</category></item><item><title>Синтаксис Python: do...while</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./12/sintaksis-python-dowhile/</link><description>&lt;p&gt;Цикл &lt;code&gt;do while&lt;/code&gt; отличается от цикла &lt;code&gt;while&lt;/code&gt; тем, что в &lt;code&gt;do while&lt;/code&gt; сначала выполняется тело цикла, а затем проверяется условие продолжения цикла.
Из-за такой особенности &lt;code&gt;do while&lt;/code&gt; называют циклом с постусловием. Таким образом, если условие &lt;code&gt;do while&lt;/code&gt; заведомо ложное, то хотя бы один раз блок операторов в теле цикла &lt;code&gt;do while&lt;/code&gt; выполнится.&lt;/p&gt;
&lt;p&gt;Иииии.... такой конструкции - &lt;code&gt;do...while&lt;/code&gt; нет в Python. Написать цикл с постусловие можно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;fail_condition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;или так&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;fail_condition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 12 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-12:posts/2015/окт./12/sintaksis-python-dowhile/</guid><category>while</category><category>синтаксис</category></item><item><title>Python проекты: интерпретатор PyPy</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./10/python-proekty-interpretator-pypy/</link><description>&lt;p&gt;PyPy — это интерпретатор Python, который написан на Python (RPython) и может компилировать сам себя.&lt;/p&gt;
&lt;p&gt;Основное отличие от обычного CPython — наличие JIT компилятора.
Прелесть JIT компилятора в том, что в течении работы программы оптимизируются ее части.&lt;/p&gt;
&lt;p&gt;Скорость исполнения кода на PyPy выше. На сайте http://speed.pypy.org/ вы можете найти сравнения CPython и PyPy.
На сайте есть график (в самом низу):
На графике видно, что скорость исполнения одного и того же кода на CPython и PyPy различается в среднем в 7 раза.&lt;/p&gt;
&lt;p&gt;Неплохо да? Ничего не изменяли в программе, а прирост в 7 раз получили.
Да еще и памяти кушает меньше с многопоточностью там хорошо.&lt;/p&gt;
&lt;p&gt;А теперь ложка дегтя:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyPy развивается медленно, сейчас две версии: одна базируется на CPython 2.7.10, другая на 3.2.5&lt;/li&gt;
&lt;li&gt;Так как PyPy имеет JIT компилятор, то есть время разогрева. Это такое время, когда код и данные оптимизируются.&lt;/li&gt;
&lt;li&gt;Не все библиотеки поддерживают PyPy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ссылочки: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pypy.org/"&gt;http://pypy.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/ru/library/os-pypy-intro/"&gt;http://www.ibm.com/developerworks/ru/library/os-pypy-intro/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 10 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-10:posts/2015/окт./10/python-proekty-interpretator-pypy/</guid><category>pypy</category></item><item><title>Hardcore Python: переопределяем механизм импорта</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./08/hardcore-python-pereopredeliaem-mekhanizm-importa/</link><description>&lt;p&gt;В стандартной Python начиная с 2.3 существует механизм импорт-хуков. 
Зачем они нужны? 
Все очень просто - захотелось добавить поддержку импорта из .zip архивов. Ява такое может (.jar) - чем Питон хуже?
Но открывать редактор только ради .zip не очень... Поэтому Python умеет загружать модули из базы данных или с соседнего сервера.&lt;/p&gt;
&lt;p&gt;Механизм механизм импорт-хуков реализован с помощью:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys.meta_path&lt;/li&gt;
&lt;li&gt;sys.path_hooks&lt;/li&gt;
&lt;li&gt;sys.path_import_cache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Как ими пользоваться отлично описано в статье Андрея Светлова (1 ссылка в приложении), поэтому здесь повторять не буду.&lt;/p&gt;
&lt;p&gt;Ссылки чтобы сломать мозг:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://asvetlov.blogspot.ru/2010/05/3.html"&gt;http://asvetlov.blogspot.ru/2010/05/3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0302/"&gt;https://www.python.org/dev/peps/pep-0302/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/sys.html"&gt;https://docs.python.org/3/library/sys.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://xion.org.pl/2012/05/06/hacking-python-imports/"&gt;http://xion.org.pl/2012/05/06/hacking-python-imports/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 08 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-08:posts/2015/окт./08/hardcore-python-pereopredeliaem-mekhanizm-importa/</guid><category>sys</category><category>стандартная библиотека</category></item><item><title>Опыт разработчиков: замыкания (closure). Зачем и почему.</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./08/opyt-razrabotchikov-zamykaniia-closure-zachem-i-pochemu/</link><description>&lt;p&gt;В синтаксисе Python один и тот же символ или конструкция часто используется для разных целей
Возможно вы встречались с подобным кодом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outer_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# inner_func замкнуло в себе х&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner_func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Похож на декоратор. Это называется замыканием. Это более общий случай декоратора.
Смысл замыкания состоит в том, что определение функции "замораживает" окружающий её контекст на момент определения. Это может делаться различными способами, например, за счёт параметризации создания функции&lt;/p&gt;
&lt;p&gt;Такой подход позволяет:
Устранить жестко кодированные константы
Убрать глобальные переменные из кода
Увеличить производительность
Если первые два пункта весьма понятны, то третий поясню. В Python загрузка переменных в SCOPE (локальную область) долгий процесс (сравнительно), поэтому чем реже это делается - тем быстрее код. 
Пример: функция, которая делает insert в базу данных. Можно объявить коннект в замыкании и использовать.&lt;/p&gt;
&lt;p&gt;Есть один нюанс. В Питоне замкнутые переменные доступны только для чтения. Чтобы обойти такое ограничение, нужно замыкать переменные в изменяемые переменные, например, в список. Сами замкнутые переменные нельзя будет перезаписывать, а вот содержимое контейнера - пожалуйста.&lt;/p&gt;
&lt;p&gt;Замкнемся на ссылки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.jetfix.ru/post/zamykaniya-v-python-chto-eto-i-s-chem-ih-edyat"&gt;http://blog.jetfix.ru/post/zamykaniya-v-python-chto-eto-i-s-chem-ih-edyat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/ru/library/l-python_details_03/"&gt;https://www.ibm.com/developerworks/ru/library/l-python_details_03/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 08 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-08:posts/2015/окт./08/opyt-razrabotchikov-zamykaniia-closure-zachem-i-pochemu/</guid><category>замыкание</category><category>closure</category></item><item><title>Пишем web-проекты: полиморфные связи или Foreign Key на две Django модели</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./07/pishem-web-proekty-polimorfnye-sviazi-ili-foreign-key-na-dve-django-modeli/</link><description>&lt;p&gt;Представим ситуацию. 
Есть модель Текст (заголовок, тело, теги) и модели Новость, Продукт, Реклама, которые имеют свои уникальные параметры. 
Необходимо связать Текст и все остальные - вполне логичное желание. &lt;/p&gt;
&lt;p&gt;Как можно поступить:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Добавить Foreign Key в Текст (т.е. будет N=3 Foreign Key полей)&lt;/li&gt;
&lt;li&gt;Сделать отдельные модели для связи - будет 3 таблицы для связки. (вручную их сделаем)&lt;/li&gt;
&lt;li&gt;Сделать 2 поля, одно из которых будет говорить, какая модель имеется в виду, а второе – хранить ключ этой модели. + добавить свойство, которое будет возвращать запись из нужной модели (делать нужный query запрос) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Первый вариант не подходит, потому что каждая новая модель будет добавлять еще одну Foreign Key связь
Второй не очень, потому что N моделей - N дополнительных таблиц делать руками
А вот третий вариант неплохой. Он и реализован в Django и состоит из двух компонентов: Content Types Framework и Generic Relations.&lt;/p&gt;
&lt;p&gt;Вот простой пример: реализуем систему тэгов(ярлычков), которая могла бы выглядеть так&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.db&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;models&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.contrib.contenttypes.fields&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;GenericForeignKey&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.contrib.contenttypes.models&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ContentType&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TaggedItem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SlugField&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;content_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ContentType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;object_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PositiveIntegerField&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;content_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GenericForeignKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;content_type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;object_id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__str__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;              &lt;span class="c"&gt;# __unicode__ on Python 2&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Обычное поле ForeignKey может “указывать” только на одну модель, что означает, - если в модели TaggedItem есть поле ForeignKey, его можно “связать” с одной и только одной моделью, для которой и будут сохраняться тэги. Приложение contenttypes предоставляет нам поле специального типа (GenericForeignKey), которое решает обозначенную выше проблему и позволяет создать связь с любой моделью&lt;/p&gt;
&lt;p&gt;Ссылки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/1.8/ref/contrib/contenttypes/"&gt;https://docs.djangoproject.com/en/1.8/ref/contrib/contenttypes/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://djbook.ru/rel1.8/ref/contrib/contenttypes.html"&gt;http://djbook.ru/rel1.8/ref/contrib/contenttypes.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://axiacore.com/blog/how-use-genericforeignkey-django/"&gt;http://axiacore.com/blog/how-use-genericforeignkey-django/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ikrvss.ru/2010/11/09/django-polymorphic-foreign-key/"&gt;http://www.ikrvss.ru/2010/11/09/django-polymorphic-foreign-key/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 07 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-07:posts/2015/окт./07/pishem-web-proekty-polimorfnye-sviazi-ili-foreign-key-na-dve-django-modeli/</guid><category>django</category><category>generic</category><category>foreign key</category></item><item><title>Учебные материалы: научная графика в python</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./06/uchebnye-materialy-nauchnaia-grafika-v-python/</link><description>&lt;p&gt;На русском языке не так много хороший книг, но есть. Среди них выделяется пособие Шабанова Павла.&lt;/p&gt;
&lt;p&gt;Данное электронное пособие на русском языке посвящено работе с научной графикой с помощью графической библиотекой matplotlib языка программирования python.&lt;/p&gt;
&lt;p&gt;Учебник предназначен для всех желающих освоить библиотеку matplotlib для создания научной графики в python. Книга будет интересна студентам, аспирантам и научным сотрудникам всех возрастов.&lt;/p&gt;
&lt;p&gt;Главная цель пособия - облегчить изучение библиотеки matplotlib и предложить ряд готовых решений для создания научной графики высокого публикационного качества. Приведённые в учебнике примеры показывают возможности языка python для визуализации результатов научной деятельности.&lt;/p&gt;
&lt;p&gt;Ссылка на книгу:
&lt;a href="https://github.com/whitehorn/Scientific_graphics_in_python"&gt;https://github.com/whitehorn/Scientific_graphics_in_python&lt;/a&gt; &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 06 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-06:posts/2015/окт./06/uchebnye-materialy-nauchnaia-grafika-v-python/</guid><category>наука</category><category>графика</category><category>график</category></item><item><title>Полезные инструменты: tox как средство тестирования</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./06/poleznye-instrumenty-tox-kak-sredstvo-testirovaniia/</link><description>&lt;p&gt;Если вы автор Python-библиотеки, то скорее всего вам необходимо поддерживать несколько версий Python.
Стандартный набор - 2.6, 2.7, 3.3, 3.4 и сейчас уже 3.5. Поддерживать несколько версий Python помогают тесты. &lt;/p&gt;
&lt;p&gt;Не секрет, что тесты помогают допускать меньше ошибок во время поддержки проекта. Например, вы можете смелее делать рефакторинг и быть уверены, что функционал который проверяют тесты работает. &lt;/p&gt;
&lt;p&gt;Пускай написали тесты для озвученных версий Python, как их запускать? Постоянно менять venv и тыкать python run_test.py?
Есть удобнее инструмент - &lt;code&gt;tox&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;tox - это средство автоматизации, которое позволяет свести запуск тестирования до одной команды (а можно и до 0).
В конфиг файле tox.ini вы можете указать:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Что установить&lt;/li&gt;
&lt;li&gt;Какие версии Python использовать&lt;/li&gt;
&lt;li&gt;Что сделать перед запуском тестов&lt;/li&gt;
&lt;li&gt;Как запускать тесты&lt;/li&gt;
&lt;li&gt;Что делать после запуска тестов (например, сделать отчет с помощью coverage, послать отчет на email)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Конфиг файл может выглядеть так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[tox]&lt;/span&gt;
&lt;span class="na"&gt;envlist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;py26,py27&lt;/span&gt;
&lt;span class="k"&gt;[testenv]&lt;/span&gt;
&lt;span class="na"&gt;deps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;pytest       # install pytest in the venvs&lt;/span&gt;
&lt;span class="na"&gt;commands&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;py.test  # or &amp;#39;nosetests&amp;#39; or ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылка на документацию: &lt;a href="https://tox.readthedocs.org/en/latest/"&gt;https://tox.readthedocs.org/en/latest/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 06 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-06:posts/2015/окт./06/poleznye-instrumenty-tox-kak-sredstvo-testirovaniia/</guid><category>tox</category><category>test</category><category>тест</category><category>автоматизация</category></item><item><title>Таинство стандартной библиотеки: functools.lru_cache — кэшируем результат выполнения функции</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./05/tainstvo-standartnoi-biblioteki-functoolslru_cache-keshiruem-rezultat-vypolneniia-funktsii/</link><description>&lt;p&gt;&lt;img alt="Image" src="http://amnesia.me/images/amnesia%20humor.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Начиная с версии 3.2, в Python появилась возможность стандартными средствами организовать мемоизацию. Иными словами, кэшировать результаты вызова функции. Этот механизм представлен в виде декоратора в модуле &lt;code&gt;functools&lt;/code&gt; и называется &lt;code&gt;lru_cache&lt;/code&gt; (least recently used cache).&lt;/p&gt;
&lt;p&gt;На примере изъезженных чисел Фибоначчи это выглядит так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@lru_cache&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maxsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;55&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;89&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;144&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;377&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;610&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_info&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;CacheInfo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;misses&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;currsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Схема вычисления числа Фибоначчи для 6 без кэша:
&lt;img alt="Image" src="https://upload.wikimedia.org/wikibooks/ru/d/dc/Fibtree.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Легко заметить, что есть повторяющиеся поддеревья, которые можно заново не вычислять. Однако, если у нас нет кэша, то куча времени уйдет на вычисление уже известных значений. Декоратор @lru_cache добавляет кэш необходимого размера (по умолчанию ёмкостью в 128 результатов), тем самым позволяя ускорить исполнение кода. &lt;/p&gt;
&lt;p&gt;Ссылка для изучения:
- &lt;a href="https://docs.python.org/3.4/library/functools.html"&gt;https://docs.python.org/3.4/library/functools.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 05 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-05:posts/2015/окт./05/tainstvo-standartnoi-biblioteki-functoolslru_cache-keshiruem-rezultat-vypolneniia-funktsii/</guid><category>functools</category><category>стандартная библиотека</category><category>кэш</category><category>cache</category></item><item><title>Таинство стандартной библиотеки: multiprocessing</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./04/tainstvo-standartnoi-biblioteki-multiprocessing/</link><description>&lt;p&gt;GIL Python снимает множество головной боли с программиста, но и не дает малой кровью использовать всю мощь CPU. 
А что если реально надо быстрее исполнить код? Например, надо сделать 1000 запросов в web. 
Можно завести несколько параллельных потоков или даже процессов. Вот с процессами только беда - как их синхронизировать между собой?&lt;/p&gt;
&lt;p&gt;В этом случае выходит на сцену модуль &lt;code&gt;multiprocessing&lt;/code&gt;. 
multiprocessing позволяет работать с процессам как с потоками. Это значит, что модуль берет на себя проблему синхронизации отдельных Python-процессов. Много процессов - много GIL'ов (каждый в своем процессе) - нет проблем с использованием процессора.&lt;/p&gt;
&lt;p&gt;Пример использования может быть такой:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;subprocess&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PIPE&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;multiprocessing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;proc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;python ./dsTest.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# дождаться выполнения&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;## получить то, что вернул подпроцесс&lt;/span&gt;

&lt;span class="n"&gt;allProcesses&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
    &lt;span class="n"&gt;allProcesses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;allProcesses&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;qsize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Казалось бы, много процессов - процессор заполнен на полную, но есть же лежка дегтя? Ложка дегтя - это синхронизация процессов. Именно на этом процессе могут быть основные траты ресурсов.&lt;/p&gt;
&lt;p&gt;Читаем дальше по ссылкам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/multiprocessing.html"&gt;https://docs.python.org/3.5/library/multiprocessing.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/multiprocessing/"&gt;https://pymotw.com/2/multiprocessing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://toly.github.io/blog/2014/02/13/parallelism-in-one-line/"&gt;http://toly.github.io/blog/2014/02/13/parallelism-in-one-line/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/ru/library/l-python_details_05/"&gt;https://www.ibm.com/developerworks/ru/library/l-python_details_05/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://antonkonovalov.blogspot.ru/2011/12/python.html"&gt;http://antonkonovalov.blogspot.ru/2011/12/python.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 04 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-04:posts/2015/окт./04/tainstvo-standartnoi-biblioteki-multiprocessing/</guid><category>multiprocessing</category></item><item><title>Таинство стандартной библиотеки: logging</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./03/tainstvo-standartnoi-biblioteki-logging/</link><description>&lt;p&gt;&lt;code&gt;Logging&lt;/code&gt; — библиотека для удобного ведения логов в Python &lt;/p&gt;
&lt;p&gt;В любой разработке приходится рано или поздно вести логи, ведь не отдашь же заказчику программу где отладочные сообщения выводятся с помощью print, да и в дальнейшем если у заказчика что то пойдет не так то можно просто попросит показать лог и понять в чем проблема(в большинстве случаев).&lt;/p&gt;
&lt;p&gt;В чем же мощь logging:
Легко можно поместить указатель времени в каждое сообщение
Вы можете использовать разные уровни срочности ваших сообщений и фильтровать их по этому уровню
Когда Вы захотите позже найти / изменить лог-сообщения Вы не перепутаете их с другим выводом команды &lt;code&gt;print&lt;/code&gt;
Если Вы хотите вывести лог в файл, то очень легко будет игнорировать вывод лог-сообщений&lt;/p&gt;
&lt;p&gt;Чтобы начать использовать logging почти ничего делать не надо:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;

&lt;span class="c"&gt;# Сообщение отладочное&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;This is a debug message&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# Сообщение информационное&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;This is an info message&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# Сообщение предупреждение&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;This is a warning&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# Сообщение ошибки&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;This is an error message&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# Сообщение критическое&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;FATAL!!!&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Это только базовая возможность &lt;code&gt;logging&lt;/code&gt;, обо всех возможностях по ссылкам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/logging.html"&gt;https://docs.python.org/3.5/library/logging.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://python-lab.blogspot.ru/2012/08/print-logging-python.html"&gt;http://python-lab.blogspot.ru/2012/08/print-logging-python.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/144566/"&gt;http://habrahabr.ru/post/144566/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 03 Oct 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-03:posts/2015/окт./03/tainstvo-standartnoi-biblioteki-logging/</guid><category>log</category><category>logging</category><category>print</category></item><item><title>Интересные концепции: mixin'ы (примеси)</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./01/interesnye-kontseptsii-mixiny-primesi/</link><description>&lt;p&gt;В определенных случаях множественное наследование это зло. 
Добро - когда классы родители не перекрывают друг друга. Частный случай такой схемы - примиси == миксины == mixin == mix in.
Концепция примисей строится на идеи четкого разделения свойств и методов для сущностей. &lt;/p&gt;
&lt;p&gt;Например,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;если есть летающее животное, то можно смело иметь метод fly;&lt;/li&gt;
&lt;li&gt;если есть раскрашиваемый объект, то можно завести методы "покрасить", и два состояния - "раскрашен" (&lt;code&gt;bool&lt;/code&gt;) и цвет.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Использование миксин выглядит так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Mixin1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Mixin1&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Mixin2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Mixin2&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BaseClass&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mixin1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Mixin2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(смотрели видео "Super - это супер"?)&lt;/p&gt;
&lt;p&gt;В чем отличие от обычного наследования?
По синтаксису - ни в чем. Отличия на уровне договоренностей и использовании - в mixin-класс помещают все необходимое и достаточное для определения сущности. &lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;есть изменяемый объект - все действия с таким объектом храним в миксине.&lt;/li&gt;
&lt;li&gt;есть итерируемый объект - тоже миксин.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Комбинируем два этих элемента и получаем интерируемый изменяемый объект.&lt;/p&gt;
&lt;p&gt;Погружаемся в множественное наследование:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qualcode.ru/article/python_mixin/"&gt;http://qualcode.ru/article/python_mixin/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ianlewis.org/en/mixins-and-python"&gt;https://www.ianlewis.org/en/mixins-and-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.o2b.ru/python-mixins/"&gt;http://www.o2b.ru/python-mixins/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/140298/"&gt;http://habrahabr.ru/post/140298/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 01 Oct 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-01:posts/2015/окт./01/interesnye-kontseptsii-mixiny-primesi/</guid><category>примесь</category><category>mixin</category></item><item><title>Полезные инструменты: pythontutor.com</title><link>http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./01/poleznye-instrumenty-pythontutorcom/</link><description>&lt;p&gt;Полезные инструменты: pythontutor.com&lt;/p&gt;
&lt;p&gt;Представим ситуацию, вы читаете лекцию, пускай студентам. Хочется все по шагам и подробно рассказать о данном куске кода.
Можно вести славеса пол часа, а можно продемонстрировать с помощью http://www.pythontutor.com/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 01 Oct 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-10-01:posts/2015/окт./01/poleznye-instrumenty-pythontutorcom/</guid></item><item><title>Полезные инструменты: pylint - в поисках ошибок</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./30/poleznye-instrumenty-pylint-v-poiskakh-oshibok/</link><description>&lt;p&gt;Статический анализ кода — анализ кода без реального исполнения кода.
Под словом "анализ" можно понимать многое - что код соответствует PEP8, что код безопасный (все типы верно приведены), что код не содержит логических ошибок.&lt;/p&gt;
&lt;p&gt;Самым придирчивым анализатором является pylint.&lt;/p&gt;
&lt;p&gt;Pylint анализирует исходный код, выводит небольшую статистику по нему и делает около 150 проверок на разного рода ошибки. Все найденные ошибки выводятся в списке.&lt;/p&gt;
&lt;p&gt;Все сообщения об ошибках делятся на 4 типа:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ошибки;&lt;/li&gt;
&lt;li&gt;потенциальные ошибки;&lt;/li&gt;
&lt;li&gt;следование стилистике и соглашениям (PEP8 и прочее);&lt;/li&gt;
&lt;li&gt;предложения по рефакторингу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Узнать мощь инструмента можно по ссылкам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.pylint.org/"&gt;http://www.pylint.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tiendil.livejournal.com/23215.html"&gt;http://tiendil.livejournal.com/23215.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dmalinovsky.blogspot.ru/2011/03/python.html"&gt;http://dmalinovsky.blogspot.ru/2011/03/python.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rtfm.co.ua/python-pylint-analiz-oshibok-i-kachestva-koda/"&gt;http://rtfm.co.ua/python-pylint-analiz-oshibok-i-kachestva-koda/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/114745/"&gt;http://habrahabr.ru/post/114745/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 30 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-30:posts/2015/сент./30/poleznye-instrumenty-pylint-v-poiskakh-oshibok/</guid><category>pylint</category><category>анализатор</category><category>ошибка</category><category>поиск ошибок</category><category>статический анализ</category><category>статический анализатор</category></item><item><title>Полезные библиотеки: langid.py</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./30/poleznye-biblioteki-langidpy/</link><description>&lt;p&gt;Представим ситуацию: есть блог, в котором публикуются посты на двух языках (а может и на 10). Необходимо рассортировать посты по языкам в разные RSS. (постов очень много, пускай 1000)&lt;/p&gt;
&lt;p&gt;Вопрос к аудитории - как вы решили бы такую задачу?&lt;/p&gt;
&lt;p&gt;Чтобы решить подобную задачу можно воспользоваться библиотекой &lt;code&gt;langid.py&lt;/code&gt;. 
Это небольшой инструмент, который без доступа в Интернет(!!!) может определить язык текста (и слова).&lt;/p&gt;
&lt;p&gt;Инструмент работает и из консоли, и как web сервис, а также как обычный Python-модуль:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;langid&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;langid&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;classify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;This is a test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;en&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.99999999099035441&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылка на божественный инструмент:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/saffsd/langid.py"&gt;https://github.com/saffsd/langid.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 30 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-30:posts/2015/сент./30/poleznye-biblioteki-langidpy/</guid><category>язык</category><category>language</category><category>модуль</category><category>пакет</category></item><item><title>Анонс встречи №3 сообщества PyNSK</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./29/anons-vstrechi-3-soobshchestva-pynsk/</link><description>&lt;p&gt;&lt;img alt="Image" src="http://pynsk.ru/images/event/event_3.png" /&gt;&lt;/p&gt;
&lt;p&gt;Встреча сообщества PyNSK состоится 11 октября (воскресенье) в 13 часов, в Самоваре (&lt;a href="http://go.2gis.com/b20p"&gt;http://go.2gis.com/b20p&lt;/a&gt;)
Регистрация на встречу по ссылке - &lt;a href="http://bit.ly/pynsk3_reg"&gt;http://bit.ly/pynsk3_reg&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;На встрече вас ожидает море общения и два доклада:&lt;/p&gt;
&lt;p&gt;Юра Бабуров aka buriy расскажет доклад  "Получаем текст веб-страниц из Python и как это работает"&lt;/p&gt;
&lt;p&gt;Описание: Мы рассмотрим python-библиотеку под названием readability-lxml (&lt;a href="https://github.com/buriy/python-readability"&gt;https://github.com/buriy/python-readability&lt;/a&gt;) , её применение и механизм работы для задачи извлечения текстов новостных страниц. &lt;/p&gt;
&lt;p&gt;Евгений Петренко (&lt;a href="https://vk.com/mrevgenx"&gt;https://vk.com/mrevgenx&lt;/a&gt;) погрузит нас в тему тяжелых вычислений на Python с помощью доклада "Python + GPGPU: ожидания и реалии"&lt;/p&gt;
&lt;p&gt;Описание: В докладе расскажу, как добиться дополнительного ускорения сложных вычислений. Будут разобраны подводные камни многопоточности в CUDA, перечислены особенности оптимизиции программ для графического процессора и представлены полезные средства отладки и профилирования. Дополнительно приведу примеры из собственного опыта распараллеливания и оптимизации такого рода программ.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 29 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-29:posts/2015/сент./29/anons-vstrechi-3-soobshchestva-pynsk/</guid></item><item><title>Синтаксис Python: frozenset - морозное множество</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./28/sintaksis-python-frozenset-moroznoe-mnozhestvo/</link><description>&lt;p&gt;frozenset и set, это как кортеж (&lt;code&gt;tuple&lt;/code&gt;) и список. Первые являются неизменяемыми, вторые изменяемые. &lt;/p&gt;
&lt;p&gt;Иммутабельные(неизменяемые) структуры данных - это коллекции, которые нельзя изменить. Примерно как числа. Число просто есть, его нельзя поменять. Также и иммутабельный массив — он такой, каким его создали, и всегда таким будет. Если нужно добавить элемент — придется создать новый массив.&lt;/p&gt;
&lt;p&gt;Преимущества неизменяемых структур:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Безопасно разделять ссылку между потоками&lt;/li&gt;
&lt;li&gt;Легко тестировать&lt;/li&gt;
&lt;li&gt;Легко отследить жизненный цикл (соответствует data flow)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На примере frozenset неизменяемость выглядит так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;qwerty&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;frozenset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;qwerty&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nc"&gt;set&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nc"&gt;set&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="ne"&gt;AttributeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;frozenset&amp;#39;&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;add&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 28 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-28:posts/2015/сент./28/sintaksis-python-frozenset-moroznoe-mnozhestvo/</guid><category>frozenset</category><category>set</category><category>множество</category><category>синтаксис</category></item><item><title>Таинство стандартной библиотеки: мета-классы, что это и зачем</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./26/tainstvo-standartnoi-biblioteki-meta-klassy-chto-eto-i-zachem/</link><description>&lt;p&gt;В Python все является объектом. Даже класс. Не объект класса, а сам класс.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;tuple&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Если из класса (считай "шаблон") мы создает объекты ("по шаблону делаем экземпляры"), то что делать как назвать
ситуацию, когда кто-то делает классы?
Стоит сказать зачем это может быть нужно:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;изменять типы создаваемых классов. &lt;/li&gt;
&lt;li&gt;Например, подмешивать миксины(примиси)&lt;/li&gt;
&lt;li&gt;автоматически вызывать некоторый код каждый раз, когда где-то создается класс, дочерний от данного.&lt;/li&gt;
&lt;li&gt;Например, дергать метод, который будет логгировать время запуска функции&lt;/li&gt;
&lt;li&gt;изменять параметры создаваемого дочернего класса. &lt;/li&gt;
&lt;li&gt;Например, на все функции класса повесить декоратор. (какую-то валидацию)&lt;/li&gt;
&lt;li&gt;для написания ORM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Это все позволяют реализовать мета-классы.&lt;/p&gt;
&lt;p&gt;Ссылки для чтения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hlabs.org/development/python/pro_python.html"&gt;http://hlabs.org/development/python/pro_python.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/ru/library/l-pymeta/"&gt;http://www.ibm.com/developerworks/ru/library/l-pymeta/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/145835/"&gt;http://habrahabr.ru/post/145835/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/65625/"&gt;http://habrahabr.ru/post/65625/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.iso.ru/print/rus/document5953.phtml"&gt;http://www.iso.ru/print/rus/document5953.phtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=""&gt;http://blog.jetfix.ru/post/metaklassy-razrushenie-mifov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 26 Sep 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-26:posts/2015/сент./26/tainstvo-standartnoi-biblioteki-meta-klassy-chto-eto-i-zachem/</guid></item><item><title>Опыт разработчиков: основы декларативной магии</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./25/opyt-razrabotchikov-osnovy-deklarativnoi-magii/</link><description>&lt;p&gt;&lt;img alt="embed" src="http://www.youtube.com/watch?v=luhyEER7_KM" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 25 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-25:posts/2015/сент./25/opyt-razrabotchikov-osnovy-deklarativnoi-magii/</guid><category>опыт</category><category>видео</category><category>декларативный язык</category><category>магия</category></item><item><title>Опыт разработчиков: соглашения о кодировании</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./25/opyt-razrabotchikov-soglasheniia-o-kodirovanii/</link><description>&lt;p&gt;В обществе существуют различные соглашения. Соглашения рождаются не просто так, а для того чтобы о чем-то условится и начать создавать.&lt;/p&gt;
&lt;p&gt;Для разработчика важным является соглашение о кодировании. Это своего рода свод "законов", которые принимает новый разработчик, когда погружается в проект. Чаще всего такие законы очевидны и естественны.&lt;/p&gt;
&lt;p&gt;Возьмем пример - длина строки не более 79 символов. В свое время дисплеи содержали лишь 80 столбцов, поэтому было удобно, когда код помещался на экран.
Подобные рекомендации или "законы" присущи любому популярному языку. Приглашаю с ними ознакомится по ссылке  &lt;a href="https://github.com/SalGnt/cscs"&gt;https://github.com/SalGnt/cscs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. PEP8&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image" src="http://i.imgur.com/66ON9pI.png" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 25 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-25:posts/2015/сент./25/opyt-razrabotchikov-soglasheniia-o-kodirovanii/</guid></item><item><title>Синтаксис Python: dir()</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./24/sintaksis-python-dir/</link><description>&lt;p&gt;Достался нам в наследство какой-то код. А там непонятный объект с названием &lt;code&gt;super_object_1&lt;/code&gt;. 
Как понять что это за объект?&lt;/p&gt;
&lt;p&gt;На помощь приходят встроенные функции - &lt;code&gt;type()&lt;/code&gt;, &lt;code&gt;dir()&lt;/code&gt;. Если с &lt;code&gt;type()&lt;/code&gt; все ясно - возвращает тип, то с &lt;code&gt;dir&lt;/code&gt; не совсем. &lt;/p&gt;
&lt;p&gt;dir - Возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке.
Это значит, что при вызове кода:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;super_object_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# мы получим список его методов.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Но есть тонкости:
Определение в классе метода &lt;code&gt;__dir__()&lt;/code&gt;, возвращающего список и имён, позволяет варьировать результат выполнения &lt;code&gt;dir()&lt;/code&gt; для экземпляров класса. 
Для объектов, класс которых не определил &lt;code&gt;__dir__()&lt;/code&gt;, функция попытается определить атрибуты по данным &lt;code&gt;__dict__&lt;/code&gt;.
Возвращаемый список может включать не все атрибуты, особенно в случаях с переопределенным &lt;code&gt;__getattr__()&lt;/code&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 24 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-24:posts/2015/сент./24/sintaksis-python-dir/</guid></item><item><title>Функциональный Python: fn.py</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./23/funktsionalnyi-python-fnpy/</link><description>&lt;p&gt;Функциональные аспекты, такие как чистота, иммутабельные данные весьма жизнеспособны. Какие-то из них Python хорошо поддерживает, какие-то нет (например, рекурсия).
Сегодня хочется упомянуть библиотеку fn.py. Эта библиотека добавляет синтаксический сахар в виде scala-лямбд, персистентных структур данных, стримом, а также другие элементы, которые встречаются в ФП.&lt;/p&gt;
&lt;p&gt;Рассказ о библиотеке:&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/k3az1g_Q4xE?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Исходники библиотеки: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kachayev/fn.py"&gt;https://github.com/kachayev/fn.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 23 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-23:posts/2015/сент./23/funktsionalnyi-python-fnpy/</guid><category>fp</category><category>функциональное программирование</category><category>фп</category><category>видео</category></item><item><title>Извлечение информации: grab - фреймворк для веб-парсинга</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./23/izvlechenie-informatsii-grab-freimvork-dlia-veb-parsinga/</link><description>&lt;p&gt;Grab — python библиотека для парсинга сайтов&lt;/p&gt;
&lt;p&gt;Её основные функции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Подготовка сетевого запроса (cookies, http-заголовки, POST/GET данные)&lt;/li&gt;
&lt;li&gt;Запрос на сервер (возможно через HTTP/SOCKS прокси)&lt;/li&gt;
&lt;li&gt;Получение ответа сервера и его первоначальная обработка (парсинг заголовков, парсинг cookies, определение кодировки документа, обработка редиректа (поддерживаются даже редирект в meta refresh тэге))&lt;/li&gt;
&lt;li&gt;Работа с DOM-деревом ответа (если это HTML-документ)&lt;/li&gt;
&lt;li&gt;Работа с формами (заполнение, автозаполнение)&lt;/li&gt;
&lt;li&gt;Отладка: логирование процесса в консоль, сетевых запросов и ответов в файлы&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В чем же особенность?&lt;/p&gt;
&lt;p&gt;Если scrapy — это реально паук, бегает по сети, тянет в тыщу потоков информацию, то grab — это скорее швейцарский нож, вы его берёте и начинает вдумчиво колупать сайт.&lt;/p&gt;
&lt;p&gt;Пощупать модуль:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://grablib.org/ru/"&gt;http://grablib.org/ru/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Image" src="https://s-media-cache-ak0.pinimg.com/736x/0e/ef/7e/0eef7e463459b10b3ea1f3f21b03d653.jpg" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 23 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-23:posts/2015/сент./23/izvlechenie-informatsii-grab-freimvork-dlia-veb-parsinga/</guid><category>grab</category><category>parsing</category><category>web parsing</category><category>crawler</category><category>парсинг</category></item><item><title>Тесты тесты тесты: Selenium как инструмент тестирования</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./22/testy-testy-testy-selenium-kak-instrument-testirovaniia/</link><description>&lt;p&gt;&lt;img alt="Image" src="https://pbs.twimg.com/media/BIoHXdICQAEaEoE.gif" /&gt;&lt;/p&gt;
&lt;p&gt;Selenium – это проект, в рамках которого разрабатывается серия программных продуктов с открытым исходным кодом.
Среди продуктов интересен Selenium WebDriver - это программная библиотека для управления браузерами. WebDriver представляет собой драйверы для различных браузеров и клиентские библиотеки на разных языках программирования, предназначенные для управления этими драйверами.&lt;/p&gt;
&lt;p&gt;Много слов и мало сути. А суть проста - использование такого веб-драйвера сводится к созданию бота, выполняющего всю ручную работу с браузером автоматизированно.&lt;/p&gt;
&lt;p&gt;Что может быть автоматизировано? По факту что угодно, что человек может делать вручную. Если вы пишите web проект с UI, то можете написать тесты, которые будут прокликивать все элементы UI на предмет ошибок.&lt;/p&gt;
&lt;p&gt;Материалы для погружения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.seleniumhq.org/"&gt;http://www.seleniumhq.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/152653/"&gt;http://habrahabr.ru/post/152653/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/248559/"&gt;http://habrahabr.ru/post/248559/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 22 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-22:posts/2015/сент./22/testy-testy-testy-selenium-kak-instrument-testirovaniia/</guid><category>тест</category><category>selenium</category></item><item><title>Синтаксис Python: yield from</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./21/sintaksis-python-yield-from/</link><description>&lt;p&gt;Рассмотрим еще одну страшную конструкцию в Python 3.3+ - yield from&lt;/p&gt;
&lt;p&gt;Напомню, генератор это объект который можно про итерировать только однажды. Записывается как:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
&lt;span class="c"&gt;# Или так&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Когда у нас один генератор - все хорошо. Используем его как итератор и радуемся. Но не редки ситуации когда есть два генератора:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generator2&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generator3&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;И стоит задача - проитерировать один генератор, потом второй. Но вернуть значения не в виде списка,  в виде генератора.
Здесь на помощь приходит конструкция&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;yield from &amp;lt;expr&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;где &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; - выражение, вычисление которого даёт нам итерируемый объект, из которого и вычленяется итератор. &lt;/p&gt;
&lt;p&gt;Эту конструкцию можно читать так:
&lt;code&gt;yield (вернуть значение) &amp;lt;стоп мыслей&amp;gt; from (взять значение из) &amp;lt;expr&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Используя &lt;code&gt;yield form&lt;/code&gt; задача решается так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def generator():
    yield from generator2()
    yield from generator3()
&amp;gt;&amp;gt;&amp;gt; generator()
&amp;lt;generator object generator at 0x7f60d8fb3480&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Почитать:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0380/"&gt;https://www.python.org/dev/peps/pep-0380/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-1.html"&gt;http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/132554/"&gt;http://habrahabr.ru/post/132554/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 21 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-21:posts/2015/сент./21/sintaksis-python-yield-from/</guid><category>yield from</category><category>синтаксис</category></item><item><title>Синтаксис Python: encode/decode</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./21/sintaksis-python-encodedecode/</link><description>&lt;p&gt;Вероятно, самым заметным отличием Python 2 от Python 3 является юникод.  Это нововведение упростило работу со строками. Однако, так как Python 2 еще в строю, то кодировки еще в силе и не мало разработчиков путается между encode и decode.&lt;/p&gt;
&lt;p&gt;Стоит привести картинку, которая прояснит все:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image" src="http://eli.thegreenplace.net/images/2012/01/py3_string_bytes.png" /&gt;&lt;/p&gt;
&lt;p&gt;Таким образом, если у нас есть строка:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Cool page&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;То существует множество способов (кодировок) представить ее в байтовом виде&lt;/p&gt;
&lt;p&gt;Поэтому мы и пишем:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;название кодировки&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# переводим строку байтовый вид&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;И обратно. Если у нас есть набор байт, то чтобы получить строку пишем:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;байт-строка&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;название кодировки&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# получаем из байтовой строки настоящую строку&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Подробнее:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/135913/"&gt;http://habrahabr.ru/post/135913/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3/"&gt;http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 21 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-21:posts/2015/сент./21/sintaksis-python-encodedecode/</guid><category>encode</category><category>decode</category><category>синтаксис</category></item><item><title>Таинство стандартной библиотеки: модуль operator</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./20/tainstvo-standartnoi-biblioteki-modul-operator/</link><description>&lt;p&gt;Таинство стандартной библиотеки: модуль operator&lt;/p&gt;
&lt;p&gt;Модуль operator содержит набор функций, соответствующих операторам Python.&lt;/p&gt;
&lt;p&gt;Вот некоторые функции:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# суммирует два значения&lt;/span&gt;
&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ne&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# то же, что и a!=b&lt;/span&gt;
&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attrgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# возвращает ссылку, по которой можно получить атрибут &amp;quot;id&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Казалось бы, зачем нужны они? А ответ довольно прост - функциональное программирование с использованием итераторов иногда требует создания небольших функций для простых выражений. Иногда они могут быть выражены как лямбда-функции, но некоторые операции не обязательно реализовывать самостоятельно:&lt;/p&gt;
&lt;p&gt;Код для Python 2:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки для изучения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/operator/"&gt;https://pymotw.com/2/operator/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/operator.html"&gt;https://docs.python.org/3.5/library/operator.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 20 Sep 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-20:posts/2015/сент./20/tainstvo-standartnoi-biblioteki-modul-operator/</guid><category>operator</category><category>стандартная библиотека</category></item><item><title>Функциональный Python: Python — это не Haskell</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./19/funktsionalnyi-python-python-eto-ne-haskell/</link><description>&lt;p&gt;Идеи функционального программирования довольно популярны, в том числе и в среде программистов на Python, который не является функциональным языком.
В докладе речь пойдёт об особенностях функционального стиля в Python, об его отличиях от типичных функциональных языков типа Haskell.&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/ajCLLdJYRUs?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 19 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-19:posts/2015/сент./19/funktsionalnyi-python-python-eto-ne-haskell/</guid><category>функциональное программирование</category></item><item><title>Таинство стандартной библиотеки: слабые ссылки - weakref</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./19/tainstvo-standartnoi-biblioteki-slabye-ssylki-weakref/</link><description>&lt;p&gt;Python имеет автоматическое управление памятью: подсчёт ссылок для большинства объектов и сборка мусора для удаления циклов. Память освобождается сразу после того, как была удалена последняя ссылка на объект.&lt;/p&gt;
&lt;p&gt;Этот подход отлично работает для большинства приложений, но иногда возникает необходимость вести учёт объектов только когда они используются где-нибудь ещё. К сожалению, само слежение за объектами уже создает ссылку и тем самым объекты остаются в памяти. Модуль weakref (от англ. weak reference - слабая ссылка) даёт средство для учёта объектов без создания ссылок на них. Когда объект больше не нужен, он автоматически удаляется из таблицы слабых ссылок и производится обратный вызов weakref-объектов. Типичное применение модуля - кэширование объектов, которые затратно воспроизвести снова.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;weakref&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;gc&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;             &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                   &lt;span class="c"&gt;# создаёт ссылку&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weakref&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WeakValueDictionary&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c"&gt;# словарь, использующий слабые ссылки&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;primary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;            &lt;span class="c"&gt;# не создаёт ссылки&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;primary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                &lt;span class="c"&gt;# достать объект, если он все ещё &amp;quot;жив&amp;quot;&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;                       &lt;span class="c"&gt;# удалить одну ссылку&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                &lt;span class="c"&gt;# произвести сборку мусора&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;primary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                &lt;span class="c"&gt;# запись была автоматически удалена&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;primary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C:/python31/lib/weakref.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;46&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;__getitem__&lt;/span&gt;
    &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt;
&lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;primary&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки на тему:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/weakref.html"&gt;https://docs.python.org/3/library/weakref.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pep8.ru/doc/tutorial-3.1/11.html"&gt;http://pep8.ru/doc/tutorial-3.1/11.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ilnurgi1.ru/docs/python/modules/weakref.html"&gt;http://www.ilnurgi1.ru/docs/python/modules/weakref.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 19 Sep 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-19:posts/2015/сент./19/tainstvo-standartnoi-biblioteki-slabye-ssylki-weakref/</guid><category>weakref</category><category>стандартная библиотека</category><category>слабая ссылка</category></item><item><title>Внутренности Python: импорт в Питоне</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./17/vnutrennosti-python-import-v-pitone/</link><description>&lt;p&gt;Любая программа использует импорт модулей. Но, как показал беглый опрос, далеко не все программисты представляют, как работает импорт, что содержится в модуле и как этот импорт можно расширять для своих нужд.&lt;/p&gt;
&lt;p&gt;Удивительный факт: даже англоязычные ресурсы предоставляют недостаточно информации&lt;/p&gt;
&lt;p&gt;Серия статей:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://asvetlov.blogspot.ru/2010/05/blog-post.html"&gt;http://asvetlov.blogspot.ru/2010/05/blog-post.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://asvetlov.blogspot.ru/2010/05/2.html"&gt;http://asvetlov.blogspot.ru/2010/05/2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://asvetlov.blogspot.ru/2010/05/3.html"&gt;http://asvetlov.blogspot.ru/2010/05/3.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 17 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-17:posts/2015/сент./17/vnutrennosti-python-import-v-pitone/</guid><category>импорт</category></item><item><title>Полезные библиотеки: gensim - библиотека для моделирования над текстами</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./17/poleznye-biblioteki-gensim-biblioteka-dlia-modelirovaniia-nad-tekstami/</link><description>&lt;p&gt;Gensim - библиотека Python для моделирования, тематическое моделирование документов и извлечения подобия с больших корпусов.&lt;/p&gt;
&lt;p&gt;Целевая аудитория является обработка естественного языка (НЛП) и IR сообщество.&lt;/p&gt;
&lt;p&gt;В Gensim реализованы популярные алгоритмы НЛП. Например, word2vec. Большинство реализаций алгоритмов умеет использовать несколько ядер.&lt;/p&gt;
&lt;p&gt;https://github.com/piskvorky/gensim/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 17 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-17:posts/2015/сент./17/poleznye-biblioteki-gensim-biblioteka-dlia-modelirovaniia-nad-tekstami/</guid><category>машинное обучение</category><category>обработка текста</category><category>gensim</category></item><item><title>Пишем web-проекты: Django Admin Actions</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./16/pishem-web-proekty-django-admin-actions/</link><description>&lt;p&gt;Интерфейс администратора Django достается разработчику "даром" - прописываешь немного срочек и готово.
Появляется UI где можно изменять объекты моделей - просто так нам предоставляют GRUD возможности.&lt;/p&gt;
&lt;p&gt;Но что если нам надо сделать какие-то дополнительные возможности?
Для примера такие действия есть в Python Дайджест:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Python Дайджест" src="http://pynsk.ru/images/posts/django_actions.png" /&gt;&lt;/p&gt;
&lt;p&gt;Такие возможности реализуются с помощью Django admin actions. 
Для примера так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ItemModeratorAdmin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ModelAdmin&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;actions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s"&gt;&amp;#39;_action_make_moderated&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_action_set_queue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;queryset&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;queryset&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;queue&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;_action_set_queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;short_description&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;В очередь&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Можно заметить, что добавлена функция, которая принимает request и queryset. queryset - в данном случае это набор выделенных объектов (у тех что галочки стоят). &lt;/p&gt;
&lt;p&gt;Подробная информация по ссылке:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.djangoproject.com/en/1.8/ref/contrib/admin/actions/"&gt;https://docs.djangoproject.com/en/1.8/ref/contrib/admin/actions/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 16 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-16:posts/2015/сент./16/pishem-web-proekty-django-admin-actions/</guid><category>django</category><category>admin</category><category>action</category></item><item><title>Опыт разработчиков: Работа с ошибками. Как ловить исключения и что потом с ними делать</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./15/opyt-razrabotchikov-rabota-s-oshibkami-kak-lovit-iskliucheniia-i-chto-potom-s-nimi-delat/</link><description>&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/hzVECcMI8ys?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 15 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-15:posts/2015/сент./15/opyt-razrabotchikov-rabota-s-oshibkami-kak-lovit-iskliucheniia-i-chto-potom-s-nimi-delat/</guid><category>исключение</category><category>ошибка</category></item><item><title>Опыт разработчиков: assert как средство для валидации</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./15/opyt-razrabotchikov-assert-kak-sredstvo-dlia-validatsii/</link><description>&lt;p&gt;Опыт разработчиков: assert как средство для валидации&lt;/p&gt;
&lt;p&gt;Хочется сегодня осветить такой элемент синтаксиса как assert. 
assert - это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.&lt;/p&gt;
&lt;p&gt;Какая же польза от этой проверки?
Представим что мы что-то пишем код, который получает данные из Базы Данных, производит обработку данных и загружает результат обратно. По замыслу этого кода мы должны положить в базу столько же данных сколько и получили. 
Но так как мы написали код с ошибками (случайно), то количество данных не совпадает. И что же случится?&lt;/p&gt;
&lt;p&gt;В этом случае очень хорошо себя показывает assert. Эта конструкция проверят данные и в случае не соответствия ожиданиям - бросает AssertException.&lt;/p&gt;
&lt;p&gt;Примеры кода:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;command&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Not found command&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;command&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Not valid command&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 15 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-15:posts/2015/сент./15/opyt-razrabotchikov-assert-kak-sredstvo-dlia-validatsii/</guid><category>assert</category><category>тест</category></item><item><title>Синтаксис Python: работа с матрицами</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./14/sintaksis-python-rabota-s-matritsami/</link><description>&lt;p&gt;Матрица - это, если утрировать, "табличка", N-мерный массив (чаще всего двумерный). 
Матрицы возникают не редко. Например, игровое поле, карта мира - тоже можно представить матрицей, да то же решето Эратосфена - тоже двумерный массив, или вообще - вложенные списки.&lt;/p&gt;
&lt;p&gt;Это все создает необходимость знать как работать с матрицами и какими инструментами. Модулей для работы с этими объектами не мало, самые известные - стандартный math и numpy.&lt;/p&gt;
&lt;p&gt;В Python 3.5 появился новый оператор - @
Этот оператор позволяет перемножать матрицы:&lt;/p&gt;
&lt;p&gt;a @ b&lt;/p&gt;
&lt;p&gt;Подробно о операторе:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0465/"&gt;https://www.python.org/dev/peps/pep-0465/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 14 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-14:posts/2015/сент./14/sintaksis-python-rabota-s-matritsami/</guid><category>матрица</category><category>синтаксис</category></item><item><title>Учебные материалы: книга "Программируем коллективный разум"</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./14/uchebnye-materialy-kniga-programmiruem-kollektivnyi-razum/</link><description>&lt;p&gt;Учебные материалы: книга "Программируем коллективный разум"&lt;/p&gt;
&lt;p&gt;Книга "Программируем коллективный разум" - это введение в мир машинного обучения и статистики. В ней объясняется, как делать полезные с точки зрения маркетинга выводы о поведении и предпочтениях пользователей на основе информации, ежедневно собираемой вашими и сторонними приложениями. Каждый алгоритм описан четко и кратко и сопровождается кодом, который можно сразу же включить в собственный сайт, блог, Вики или какое-нибудь специализированное приложение.&lt;/p&gt;
&lt;p&gt;Прелесть этой книги в том, что все примеры на Python. Конечно, код там не фонтан - но он есть.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Обложка" src="https://pp.vk.me/c616725/v616725138/aee5/bNOWrYAnIIw.jpg" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 14 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-14:posts/2015/сент./14/uchebnye-materialy-kniga-programmiruem-kollektivnyi-razum/</guid><category>книга</category><category>справочник</category><category>учебник</category></item><item><title>Таинство стандартной библиотеки: textwrap для сокращения текста</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./13/tainstvo-standartnoi-biblioteki-textwrap-dlia-sokrashcheniia-teksta/</link><description>&lt;p&gt;Таинство стандартной библиотеки: textwrap для укорочения текстов&lt;/p&gt;
&lt;p&gt;При работе над Python Дайджестом - &lt;a href="http://pythondigest.ru/"&gt;http://pythondigest.ru/&lt;/a&gt; а именно при работе над "Колонкой автора" возникла такая задачка - уменьшить длину описания.  Описание ссылок берется из RSS этой группы и оно иногда длинное. &lt;/p&gt;
&lt;p&gt;Как же наиболее просто решить эту задачу? Самое простое - взять строку описания и взять, скажем первые 300 символов. Просто? Только вот проблема - слово может оборваться на середине. Чтобы не обрабатывать эту ситуацию самостоятельно, можно воспользоваться модулем textwrap. &lt;/p&gt;
&lt;p&gt;textwrap это стандартный модуль, который позволяет всячески укорачивать текст. Например, можно ограничить длину строки (будет текст выводится в несколько строк).&lt;/p&gt;
&lt;p&gt;Озвученную задачу можно решить так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;textwrap&lt;/span&gt;
&lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;textwrap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shorten&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw_content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки на тему:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.dotnetperls.com/textwrap"&gt;http://www.dotnetperls.com/textwrap&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/textwrap.html"&gt;https://docs.python.org/3.5/library/textwrap.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/textwrap/"&gt;https://pymotw.com/2/textwrap/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 13 Sep 2015 15:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-13:posts/2015/сент./13/tainstvo-standartnoi-biblioteki-textwrap-dlia-sokrashcheniia-teksta/</guid><category>стандартная библиотека</category><category>обработка текста</category></item><item><title>Синтаксис Python: super() это супер</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./11/sintaksis-python-super-eto-super/</link><description>&lt;p&gt;Вы знаете что такое super()?
Думаете что это вызов метода класса родителя? Если так, то вам стоит посмотреть это видео.
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/61UuKJRl2m0?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 11 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-11:posts/2015/сент./11/sintaksis-python-super-eto-super/</guid><category>super</category><category>видео</category><category>синтаксис</category></item><item><title>Hardcore Python: Конкурентность в Питоне с нуля. Вживую</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./10/hardcore-python-konkurentnost-v-pitone-s-nulia-vzhivuiu/</link><description>&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/ys8lW8eQaJQ?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 10 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-10:posts/2015/сент./10/hardcore-python-konkurentnost-v-pitone-s-nulia-vzhivuiu/</guid><category>видео</category><category>конкурентность</category><category>многопоточность</category></item><item><title>Полезные библиотеки: funcy - набор конструкций, которые упрощают код</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./09/poleznye-biblioteki-funcy-nabor-konstruktsii-kotorye-uproshchaiut-kod/</link><description>&lt;p&gt;Полезные библиотеки: funcy - набор конструкций, которые упрощают код&lt;/p&gt;
&lt;p&gt;Есть ряд модулей, которые стоит ставить первыми. Этот набор у каждого свой. 
В моем наборе есть место для funcy. 
funcy - это набор мелких полезностей при работе с данными. &lt;/p&gt;
&lt;p&gt;Например, можно создать бесконечный список, объединить список списков, объединение словарей, можно превращать вложенные структуры в плоские и наоборот.&lt;/p&gt;
&lt;p&gt;Это не весь список возможностей - а он и вправду огромный. Посмотрите хотя бы README - &lt;a href="https://github.com/Suor/funcy"&gt;https://github.com/Suor/funcy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://habrahabr.ru/post/174619/"&gt;http://habrahabr.ru/post/174619/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. funcy - написана разработчиком из Красноярска&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 09 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-09:posts/2015/сент./09/poleznye-biblioteki-funcy-nabor-konstruktsii-kotorye-uproshchaiut-kod/</guid><category>функциональное программирование</category><category>funcy</category><category>синтаксис</category></item><item><title>Извлечение информации: скачиваем список ссылок с помощью asyncio</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./09/izvlechenie-informatsii-skachivaem-spisok-ssylok-s-pomoshchiu-asyncio/</link><description>&lt;p&gt;Порой возникают рутинные задачи, которые не хочется делать руками. Примером такой задачи может являться - скачать множество страниц по ссылкам. Если 5 ссылок еще вручную сохранить можно, а если их 1000? или 6250, как было в моем случае. &lt;/p&gt;
&lt;p&gt;На Python эту задачу можно с помощью модуля asyncio и aiohttp. &lt;/p&gt;
&lt;p&gt;Вот такой код можно написать за пару минут:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;aiohttp&lt;/span&gt;

&lt;span class="nd"&gt;@asyncio.coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;download&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;aiohttp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;save_page&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# сохраняем страницу в файл, или еще куда&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="nd"&gt;@asyncio.coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;download_parallel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;download&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;yield from&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt;список&lt;/span&gt; &lt;span class="err"&gt;ссылок&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# список ссылок&lt;/span&gt;

&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_event_loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_until_complete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;download_parallel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 09 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-09:posts/2015/сент./09/izvlechenie-informatsii-skachivaem-spisok-ssylok-s-pomoshchiu-asyncio/</guid><category>asyncio</category><category>aiohttp</category></item><item><title>Тесты тесты тесты: coverage - узнаем сколько процентов кода покрыто тестами</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./08/testy-testy-testy-coverage-uznaem-skolko-protsentov-koda-pokryto-testami/</link><description>&lt;p&gt;Тесты тесты тесты: coverage - узнаем сколько процентов кода покрыто тестами&lt;/p&gt;
&lt;p&gt;Юнит-тесты хороши, когда покрывают весь ключевой код. Однако если проект чуть больше, чем "Hello, world!", то оценить степень покрытия весьма проблематично. Существуют инструменты, которые помогают это делать. Например - coverage.py - модуль Неда Бачелдера.&lt;/p&gt;
&lt;p&gt;coverage.py - написан на основе стандартной библлиотеки, может использоваться как из командной строки, так и из кода (как библиотека). Плюс к этому, он может выдавать как суммарный результат (в процентах), так и анотированный (т.е. копия исходного файла, в котором протестированная строка помечается &amp;gt;, не протестированная - !).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nedbat/coveragepy"&gt;https://github.com/nedbat/coveragepy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 08 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-08:posts/2015/сент./08/testy-testy-testy-coverage-uznaem-skolko-protsentov-koda-pokryto-testami/</guid><category>тест</category><category>coverage</category></item><item><title>Синтаксис Python: генераторы</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./07/sintaksis-python-generatory/</link><description>&lt;p&gt;Генераторы это итерируемые объекты, которые можно прочитать лишь один раз. Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; mygenerator = (x*x for x in range(3))
&amp;gt;&amp;gt;&amp;gt; for i in mygenerator :
...    print(i)
0
1
4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Казалось бы, всего один раз можно пройти по данным. Зачем это?&lt;/p&gt;
&lt;p&gt;На практике мы редко проходим по одним и тем же данным несколько раз. 
При этом нам не всегда нужны все данные. Например, стоит задача проверить что все элементы массива положительные. Вот мы пишем цикл, в котором сравниваем элементы с нулем. И бац, попадается отрицательный элемент. Можем уже дальше не проверять и уже кинуть ошибку. При этом весь массив не находится в памяти. &lt;/p&gt;
&lt;p&gt;Это если обычные числа, а если элементы коллекции это результаты вычисления функции - вот как в коде выше, это квадраты. А элементов у нас не 3, а 1 миллион. А в данный момент нам нужны только первые 500, по ним определим нужны ли нам остальные. Вот здесь и приходят на помощь генераторы - они возвращают именно столько сколько и надо данных.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 07 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-07:posts/2015/сент./07/sintaksis-python-generatory/</guid><category>генератор</category><category>yield</category></item><item><title>Учебные материалы: Python. Подробный справочник</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./07/uchebnye-materialy-python-podrobnyi-spravochnik/</link><description>&lt;p&gt;Не так редко спрашивают "Какую книжку почитать". Ответить на такой вопрос не просто, ибо зависит от человека. Однако, есть и универсальные книги - справочники. Сегодня хочу представить аннотацию к книге - Python. Подробный справочник от Дэвида Бизли. &lt;/p&gt;
&lt;p&gt;«Python. Подробный справочник» — это авторитетное руководство и детальный путеводитель по языку программирования Python. Книга предназначена для практикующих программистов; она нацелена на суть дела и написана очень доступным языком. Она детально описывает не только ядро языка, но и наиболее важные части стандартной библиотеки Python. Дополнительно освещается ряд тем, которые не рассматриваются ни в официальной документации, ни в каких-либо других источниках.&lt;/p&gt;
&lt;p&gt;Читателю предлагается практическое знакомство с особенностями Python, включая генераторы, сопрограммы, замыкания, метаклассы и декораторы.
Подробно описаны новые модули, имеющие отношение к разработке многозадачных программ, использующих потоки управления и дочерние процессы, а также предназначенные для работы с системными службами и организации сетевых взаимодействий.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Обложка" src="http://cs310119.vk.me/v310119267/7a2c/WgBhu6OpOkY.jpg" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 07 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-07:posts/2015/сент./07/uchebnye-materialy-python-podrobnyi-spravochnik/</guid><category>книга</category><category>справочник</category><category>учебник</category></item><item><title>Таинство стандартной библиотеки: itertools</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./06/tainstvo-standartnoi-biblioteki-itertools/</link><description>&lt;p&gt;Еще один стандартный модуль в Python - itertools.
Модуль itertools - сборник полезных итераторов.&lt;/p&gt;
&lt;p&gt;В нем содержатся множество операций над итераторами, да и сами интераторы. 
Например есть бесконечная арифметическая прогрессия, можно объединять, разъединять итераторы, всячески извлекать значения как из одного так и групп итераторов, повторять итератор, группировать значения итератора и многое другое. А что именно - по ссылкам.&lt;/p&gt;
&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/itertools.html"&gt;https://docs.python.org/3.5/library/itertools.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pymotw.com/2/itertools/"&gt;https://pymotw.com/2/itertools/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/moduli/modul-itertools.html"&gt;http://pythonworld.ru/moduli/modul-itertools.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 06 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-06:posts/2015/сент./06/tainstvo-standartnoi-biblioteki-itertools/</guid><category>itertools</category></item><item><title>Таинство стандартной библиотеки: docstring</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./06/tainstvo-standartnoi-biblioteki-docstring/</link><description>&lt;p&gt;Docstring - (сокращение от documentation string, строка документации) встроенное средство документирования модулей, функций, классов и методов. Делается очень просто - сразу после определения указывается строковое значение, которое и будет docstring'ом.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;This is the test&amp;#39;s docstring&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;opa&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Получить доступ к docstring можно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__doc__&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;This is the test&amp;#39;s docstring&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Либо так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Help&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;__main__&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s docstring&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Существуют инструменты, которые позволяют извлекать docstring не по одиночке, а для целого модуля/пакета. О них и пойдет речь.&lt;/p&gt;
&lt;p&gt;Изучаем дальше: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;https://www.python.org/dev/peps/pep-0257/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pyobject.ru/blog/2006/09/08/document-it/"&gt;http://pyobject.ru/blog/2006/09/08/document-it/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/149371/"&gt;http://habrahabr.ru/post/149371/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 06 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-06:posts/2015/сент./06/tainstvo-standartnoi-biblioteki-docstring/</guid><category>docstring</category><category>документация</category></item><item><title>Полезные модули: PySide</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./05/poleznye-moduli-pyside/</link><description>&lt;p&gt;PySide — привязка языка Python к инструментарию Qt, совместимая на уровне API с PyQt. В отличие от PyQt, PySide доступна для свободного использования как в открытых, так и закрытых, в частности, коммерческих проектах, поскольку лицензирована по LGPL.&lt;/p&gt;
&lt;p&gt;Проект возник в результате нежелания создателей PyQt менять лицензионную политику для своего проекта. Свет PySide увидел в августе 2009 года, когда была выпущена первая публичная версия. Основными разработчиками PySide являются программисты Digia.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 05 Sep 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-05:posts/2015/сент./05/poleznye-moduli-pyside/</guid><category>pyside</category><category>pyqt</category><category>qt</category></item><item><title>Полезные модули: PyQt</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./05/poleznye-moduli-pyqt/</link><description>&lt;p&gt;Проекты все чаще зарождаются именно в web,  однако, и десктоп ПО еще живо, да и инструментарий к нему. В частности, кроссплатформенный фреймворк Qt имеет обертку для Python - PyQt. &lt;/p&gt;
&lt;p&gt;Уже давно все крупные GUI-фреймворки имеют дизайнер форм (в нашем случае - Qt designer). В которой вы можете набросать мышкой кнопки на формы, а уже затем в коде добавить логику работы с ними. &lt;/p&gt;
&lt;p&gt;Соединение логики и GUI в PyQt можно делать двумя способами - .ui файл (такой файл выдает дизайнер форм) конвертировать в py файл и отнаследоваться от класса. Понятно, что если идет активная разработка GUI, то придется множество раз конвертировать, что лень.
Поэтому есть более простое решение - напрямую подключать .ui файл. Для этого есть методы loadUi и loadUiType&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 05 Sep 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-05:posts/2015/сент./05/poleznye-moduli-pyqt/</guid><category>qt</category><category>pyqt</category><category>gui</category></item><item><title>Опыт разработчиков: файл requirements.txt в каждый проект</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./04/opyt-razrabotchikov-fail-requirementstxt-v-kazhdyi-proekt/</link><description>&lt;p&gt;Первой проблемой при поддержке старых проектов является понять, как запустить его. 
Чтобы немного упростить эту задачу разработчики используют pip и файл requirements.txt. В этом файле записываются все необходимые для работы библиотеки и, что самое главное, указывают версии этих библиотек. &lt;/p&gt;
&lt;p&gt;Имея такой файл настройка окружения для старта проекта может состоять из одной команды:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 04 Sep 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-04:posts/2015/сент./04/opyt-razrabotchikov-fail-requirementstxt-v-kazhdyi-proekt/</guid><category>pip</category><category>requirements.txt</category><category>requirements</category></item><item><title>Пишем web-проекты: выжимаем максимум из PostgreSQL</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./03/pishem-web-proekty-vyzhimaem-maksimum-iz-postgresql/</link><description>&lt;p&gt;Postgres предоставляет много встроенных возможностей для создания эфективных приложений,
использующих базы данных. А в версии 9.4 появляется еще и полноценное JSON поле,
при правильном использовании которого, отпадает необходимость использвания NoSQL баз данных.
В докладе мы рассмотрим, как использовать этот потенциал по максимуму в своих Python/Django
приложениях.&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/wP6pCm2zvUg?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 03 Sep 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-03:posts/2015/сент./03/pishem-web-proekty-vyzhimaem-maksimum-iz-postgresql/</guid><category>web</category><category>db</category><category>postgresql</category><category>видео</category></item><item><title>Полезные инструменты: django-debug-toolbar</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./02/poleznye-instrumenty-django-debug-toolbar/</link><description>&lt;p&gt;Разработка программ сопряжена с сложностями. Произвольно или нет лезут различные баги. Для поиска ошибок применяют различные инструменты, например дебаг. Дебаг бывает кустарным - print'ами, а есть более каноничный подход - дебаггерами.&lt;/p&gt;
&lt;p&gt;С десктоп программами все ясно - сиди тыкай точки остановки и изучай состояние программы, а что делать с web?&lt;/p&gt;
&lt;p&gt;А делать вот что - ставить debug toolbar: &lt;a href="https://github.com/django-debug-toolbar/django-debug-toolbar"&gt;https://github.com/django-debug-toolbar/django-debug-toolbar&lt;/a&gt;  Именно этот для Django, но такие есть и для других фреймворков.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 02 Sep 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-02:posts/2015/сент./02/poleznye-instrumenty-django-debug-toolbar/</guid><category>django</category><category>debug</category><category>toolbar</category><category>django-debug-toolbar</category></item><item><title>Тесты тесты тесты: doctest</title><link>http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./01/testy-testy-testy-doctest/</link><description>&lt;p&gt;Тесты можно писать прям в коде, а точнее в docstring.&lt;/p&gt;
&lt;p&gt;Модуль doctest ищет куски текста, которые выглядят как интерактивные сессии Python и затем выполняет эти сессии, чтобы проверить, что они работают точно так же, как показано. &lt;/p&gt;
&lt;p&gt;Есть несколько стандартных причин, чтобы использовать doctest:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Для того, чтобы проверить актуальность строк документации, убедившись, что все интерактивные примеры работают именно так, как задокументировано.&lt;/li&gt;
&lt;li&gt;Чтобы организовать регрессионное тестирование, проверяя, что интерактивные примеры из тестового файла или тестового объекта работают как ожидается.&lt;/li&gt;
&lt;li&gt;Чтобы написать руководство для пакета, иллюстрированное примерами ввода-вывода. В зависимости от того, на что обращается внимание - на примеры или на пояснительный текст, это можно назвать либо “литературным тестированием”, либо “исполняемой документацией”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Существует отличная статья про doctest - &lt;a href="http://python-lab.ru/documentation/27/stdlib/doctest.html"&gt;http://python-lab.ru/documentation/27/stdlib/doctest.html&lt;/a&gt;, поэтому здесь повторяться не буду.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 01 Sep 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-09-01:posts/2015/сент./01/testy-testy-testy-doctest/</guid><category>test</category><category>тест</category><category>doctest</category></item><item><title>Синтаксис Python: множества (set)</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./31/sintaksis-python-mnozhestva-set/</link><description>&lt;p&gt;Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="c"&gt;# генератор множеств&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;  &lt;span class="c"&gt;# А так нельзя!&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nc"&gt;dict&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html"&gt;http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://server.179.ru/tasks/python/2014b1/17-sets.html"&gt;http://server.179.ru/tasks/python/2014b1/17-sets.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://informatics.mccme.ru/mod/book/view.php?id=6693"&gt;http://informatics.mccme.ru/mod/book/view.php?id=6693&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 31 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-31:posts/2015/авг./31/sintaksis-python-mnozhestva-set/</guid><category>set</category></item><item><title>Синтаксис Python: оператор yield</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./31/sintaksis-python-operator-yield/</link><description>&lt;p&gt;При чтении чужого кода можно столкнутся с многими непонятными конструкциями. А сейчас хочу коротко осветить такую конструкцию как yield.
Yield - это ключевое слово которое используется так же, как и слово return. Разница в том, что функция при этом начинает возвращать генератор вместо значения.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x2e58870&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В данном случае, с практической точки зрения, это бесполезный пример. Ощутимую пользу вы получите в ситуации, когда ваша функция должна будет возвращать достаточно большой объём данных, но использовать их надо будет только один раз.
Для того чтобы до конца освоить оператор yield, вы должны знать, что когда вы вызываете функцию, в теле которой находится yield, выполнение этой функции не происходит. Вместо выполнения, функция вернёт объект-генератор. Выглядит это несколько странно на первый взгляд - функция вызвана, но код не выполнен, но, просто запомните этот факт. Код будет выполнятся при каждой итерации - будь то цикл "for &amp;lt;...&amp;gt; in &lt;generator&gt;" или вызов метода &lt;generator&gt;.next().&lt;/p&gt;
&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://zetblog.ru/programming/201304/python-iterators-generators-yield/"&gt;http://zetblog.ru/programming/201304/python-iterators-generators-yield/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/132554/"&gt;http://habrahabr.ru/post/132554/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/ru/library/l-pycon/"&gt;http://www.ibm.com/developerworks/ru/library/l-pycon/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.jetfix.ru/post/chto-takoe-yield-i-dlya-chego-eto-slovo-nuzhno"&gt;http://blog.jetfix.ru/post/chto-takoe-yield-i-dlya-chego-eto-slovo-nuzhno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 31 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-31:posts/2015/авг./31/sintaksis-python-operator-yield/</guid><category>yield</category><category>синтаксис</category></item><item><title>Таинство стандартной библиотеки: abc</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./30/tainstvo-standartnoi-biblioteki-abc/</link><description>&lt;p&gt;Абстрактные базовые классы и интерфейсы — близкие по назначению и смыслу сущности. Как первые, так и вторые представляют собой своеобразный способ документирования кода и помогают ограничить (decouple) взаимодействие отдельных абстракций в программе (классов).&lt;/p&gt;
&lt;p&gt;Питон — очень гибкий язык. Одна из граней этой гибкости — возможности, предоставляемые метапрограммированием. И хотя в ядре языка абстрактные классы и интерфейсы не представлены, первые были реализованы в стандартном модуле abc, вторые — в проекте Zope (модуль zope.interfaces).&lt;/p&gt;
&lt;p&gt;Начиная с версии языка 2.6 в стандартную библиотеку включается модуль abc, добавляющий в язык абстрактные базовые классы (далее АБК).&lt;/p&gt;
&lt;p&gt;АБК позволяют определить класс, указав при этом, какие методы или свойства обязательно переопределить в классах-наследниках&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/72757/"&gt;http://habrahabr.ru/post/72757/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/abc.html"&gt;https://docs.python.org/3/library/abc.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 30 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-30:posts/2015/авг./30/tainstvo-standartnoi-biblioteki-abc/</guid><category>память</category></item><item><title>Внутренности Python: на что уходит память</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./30/vnutrennosti-python-na-chto-ukhodit-pamiat/</link><description>&lt;p&gt;Часто утверждают, что Python жрет очень много памяти. 
В этом видео вы узнаете как Python работает с памятью&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/XwpUQX_8rmY?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 30 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-30:posts/2015/авг./30/vnutrennosti-python-na-chto-ukhodit-pamiat/</guid><category>память</category><category>видео</category></item><item><title>Полезные инструменты: pycallgraph</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./29/poleznye-instrumenty-pycallgraph/</link><description>&lt;p&gt;Идеальный программист не пишет тесты, потому что у него не бывает ошибок. А сверх идеальный программист даже код не пишет. &lt;/p&gt;
&lt;p&gt;А так как идеальных нет, поэтому бывают медленные куски программы. Точнее как, обычно это называем "тормозит". Чтобы понять какое место тормозит можно воспользоваться модулем pycallgraph - https://github.com/gak/pycallgraph&lt;/p&gt;
&lt;p&gt;Данный модуль строит красивые графики-графы, в которых цветом выделяет медленные места программы. Очень удобно.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 29 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-29:posts/2015/авг./29/poleznye-instrumenty-pycallgraph/</guid><category>pycallgraph</category></item><item><title>Python на службе народа: создаем бота для Telegram</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./28/python-na-sluzhbe-naroda-sozdaem-bota-dlia-telegram/</link><description>&lt;p&gt;Развитие общества обладает цикличностью. Лет 30-25 назад были популярны чаты, лет 15-10 назад тоже чаты были на коне. И сейчас снова. Только теперь это называют словом мессенджер.&lt;/p&gt;
&lt;p&gt;Хочется привести информацию о создании бота для мессенджера Telegram.&lt;/p&gt;
&lt;p&gt;24 июня разработчики Telegram открыли платформу для создания ботов. &lt;/p&gt;
&lt;p&gt;Прежде всего, бот для Telegram — это по-прежнему приложение, запущенное на вашей стороне и осуществляющее запросы к Telegram Bot API. Причем API довольное простое — бот обращается на определенный URL с параметрами, а Telegram отвечает JSON объектом.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://habrahabr.ru/post/262247/"&gt;http://habrahabr.ru/post/262247/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 28 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-28:posts/2015/авг./28/python-na-sluzhbe-naroda-sozdaem-bota-dlia-telegram/</guid><category>IPython</category></item><item><title>Полезные инструменты: IPython</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./28/poleznye-instrumenty-ipython/</link><description>&lt;p&gt;IPython - интерактивная оболочка для языка программирования Python, которая предоставляет расширенную интроспекцию, дополнительный командный синтаксис, подсветку кода и автоматическое дополнение.&lt;/p&gt;
&lt;p&gt;IPython весьма удобен для демонстраций и экспериментов. В отличие от стандартного REPL, IPython может запоминать введенные команды. А IPython Notebook позволяет сохранить все свои эксперименты в файл, после чего залить на сервис для просмотра другими. Даже github поддерживает отображение этих "книг".&lt;/p&gt;
&lt;p&gt;IPython хорошо себя зарекомендовал из-за расширений. С помощью расширений можно подключать самые различные модули. И что немного "странно" - использовать другие языки совместно с Python. Например, вы можете написать часть своего эксперимента на R, а часть на Python - и они будут работать совместно.&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/9iwfJvSh004?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 28 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-28:posts/2015/авг./28/poleznye-instrumenty-ipython/</guid><category>IPython</category><category>видео</category></item><item><title>Функциональный Python: пробуем функциональщину</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./27/funktsionalnyi-python-probuem-funktsionalshchinu/</link><description>&lt;p&gt;Существует два основных подхода в программировании - декларативный и императивный. 
Каждый из них имеет свои достоинства и недостатки. Крайнее время декларативный подход, а в частности функциональное программирование стало весьма популярным. Давайте ознакомимся с ним:
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/DblOFqPE1Pk?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 27 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-27:posts/2015/авг./27/funktsionalnyi-python-probuem-funktsionalshchinu/</guid><category>fp</category><category>функциональное программирование</category><category>видео</category></item><item><title>Пишем web-проекты: туториал по django</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./26/pishem-web-proekty-tutorial-po-django/</link><description>&lt;p&gt;Django - это крупный web-фреймворк. Это отличный инструмент для создания web-приложений. Освоение этого инструмента занимает приличное количество времени.
А начать можно с туториала - &lt;a href="https://docs.djangoproject.com/en/stable/intro/tutorial01/"&gt;https://docs.djangoproject.com/en/stable/intro/tutorial01/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 26 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-26:posts/2015/авг./26/pishem-web-proekty-tutorial-po-django/</guid><category>django</category></item><item><title>Полезные библиотеки: генерация html с помощью Yattag</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./26/poleznye-biblioteki-generatsiia-html-s-pomoshchiu-yattag/</link><description>&lt;p&gt;В PyPi репозитории не один шаблонизатор HTML. Но далеко не всегда хочется тащить его за собой.
В этом случае нам поможет модуль Yattag - это библиотека (DSL по сути), которая позволяет в Python-way формате писать HTML/XML файлы&lt;/p&gt;
&lt;p&gt;Ознакомьтесь с туториалом:
&lt;a href="http://www.yattag.org/#tutorial"&gt;http://www.yattag.org/#tutorial&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 26 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-26:posts/2015/авг./26/poleznye-biblioteki-generatsiia-html-s-pomoshchiu-yattag/</guid><category>html</category><category>yattag</category></item><item><title>Пишем web-проекты: обзор и сравнение методов реализации REST API в Django</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./25/pishem-web-proekty-obzor-i-sravnenie-metodov-realizatsii-rest-api-v-django/</link><description>&lt;p&gt;Без API уже тяжело представить веб-проект. Для django существует несколько библиотек, которые позволяют создать REST API за пару строк. &lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/nEl2ymv2QnA?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 25 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-25:posts/2015/авг./25/pishem-web-proekty-obzor-i-sravnenie-metodov-realizatsii-rest-api-v-django/</guid><category>rest</category><category>api</category><category>django</category><category>видео</category></item><item><title>Опыт разработчиков: пишем совместимый код (Python 2 и 3)</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./25/opyt-razrabotchikov-pishem-sovmestimyi-kod-python-2-i-3/</link><description>&lt;p&gt;Python 3 вышел в 2008 году, однако, до сих пор не все перешли на новую версию. Раньше основными аргументами, чтобы не начинать новые проекты на Python были - библиотеки не готовы к использованию, нет особых фич.&lt;/p&gt;
&lt;p&gt;Первое уже вполне решено - &lt;a href="https://python3wos.appspot.com/"&gt;https://python3wos.appspot.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А второе, начиная с Python 3.3 уже слабо актуально - много новых фич введено.&lt;/p&gt;
&lt;p&gt;Поэтому теперь актуально писать совместимый код. Для наиболее легкого написания кода одинаково работающего как в Python 2.6+ так и в Python 3.* рекомендуется использовать библиотеку six.&lt;/p&gt;
&lt;p&gt;В ней собрано большее количество инструментов позволяющих писать кросверсионный код для Python 2.x-3.x. Для нахождения мест подлежащих изменению рекомендуется воспользоваться утилитами 2to3 или python-modernize.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pythonhosted.org/six/"&gt;https://pythonhosted.org/six/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/2.7/library/2to3.html"&gt;http://docs.python.org/2.7/library/2to3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mitsuhiko/python-modernize"&gt;https://github.com/mitsuhiko/python-modernize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 25 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-25:posts/2015/авг./25/opyt-razrabotchikov-pishem-sovmestimyi-kod-python-2-i-3/</guid><category>python2</category><category>python3</category></item><item><title>Синтаксис Python: with ... as</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./24/sintaksis-python-with-as/</link><description>&lt;p&gt;Конструкция &lt;code&gt;with ... as&lt;/code&gt; используется для оборачивания выполнения блока инструкций менеджером контекста. Иногда это более удобная конструкция, чем &lt;code&gt;try...except...finally&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Синтаксис конструкции &lt;code&gt;with ... as&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;with&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;as&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;as&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;suite&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Теперь по порядку о том, что происходит при выполнении данного блока:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Выполняется выражение в конструкции &lt;code&gt;with ... as&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Загружается специальный метод &lt;code&gt;__exit__&lt;/code&gt; для дальнейшего использования.&lt;/li&gt;
&lt;li&gt;Выполняется метод &lt;code&gt;__enter__&lt;/code&gt;. Если конструкция &lt;code&gt;with&lt;/code&gt; включает в себя слово &lt;code&gt;as&lt;/code&gt;, то возвращаемое методом &lt;code&gt;__enter__&lt;/code&gt; значение записывается в переменную.&lt;/li&gt;
&lt;li&gt;Выполняется suite.&lt;/li&gt;
&lt;li&gt;Вызывается метод &lt;code&gt;__exit__&lt;/code&gt;, причём неважно, выполнилось ли suite или произошло исключение. В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение None, если исключения не было.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Примером использования данной конструкции является чтение и запись из/в файл (гарантированное закрытие файла)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://effbot.org/zone/python-with-statement.htm"&gt;http://effbot.org/zone/python-with-statement.htm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html"&gt;http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/reference/compound_stmts.html"&gt;https://docs.python.org/2/reference/compound_stmts.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 24 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-24:posts/2015/авг./24/sintaksis-python-with-as/</guid><category>синтаксис</category><category>with</category></item><item><title>Синтаксис Python: знакомимся с синтаксисом за Y минут</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./24/sintaksis-python-znakomimsia-s-sintaksisom-za-y-minut/</link><description>&lt;p&gt;Когда мне необходимо быстро вникнуть в синтаксис языка X, то использую этот сайт:
&lt;a href="http://learnxinyminutes.com/docs/ru-ru/python3-ru/"&gt;http://learnxinyminutes.com/docs/ru-ru/python3-ru/&lt;/a&gt;
А по ссылке вы найдете синтаксис языка Python&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 24 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-24:posts/2015/авг./24/sintaksis-python-znakomimsia-s-sintaksisom-za-y-minut/</guid><category>синтаксис</category></item><item><title>Hardcore Python: запускаем С код с помощью cffi</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./23/hardcore-python-zapuskaem-s-kod-s-pomoshchiu-cffi/</link><description>&lt;p&gt;Самый популярный Python это CPython. Он настолько популярен, что когда говорят Python имеют ввиду именно каноническую реализацию - CPython.&lt;/p&gt;
&lt;p&gt;CPython, как можно понять из названия, имеет какое-то отношение к языку C.
Из Python вы можете с помощью ctypes дергать С-шные функции.&lt;br /&gt;
Однако, этот механизм несколько медленный и не всегда удобный - бывает надо просто дернуть один кусок C-кода. Или надо только часть от h-файла, или только кусок структуры.
Вот в этом случае помогает - cffi.&lt;/p&gt;
&lt;p&gt;Пример кода с использованием этой библиотеки:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;cffi&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;FFI&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ffi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FFI&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ffi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cdef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;.......int printf(const char *format, ...);   // copy-pasted from the man page&lt;/span&gt;
&lt;span class="s"&gt;.......&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ffi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="c"&gt;# loads the entire C namespace&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ffi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;char[]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c"&gt;# equivalent to C code: char arg[] = &amp;quot;world&amp;quot;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hi there, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c"&gt;# call printf&lt;/span&gt;
&lt;span class="n"&gt;hi&lt;/span&gt; &lt;span class="n"&gt;there&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="mi"&gt;17&lt;/span&gt;                                           &lt;span class="c"&gt;# this is the return value&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Эти многоточия в cdef это &lt;em&gt;реальный&lt;/em&gt; код, который надо писать.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cffi.readthedocs.org/en/latest/"&gt;https://cffi.readthedocs.org/en/latest/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/cffi"&gt;https://pypi.python.org/pypi/cffi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 23 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-23:posts/2015/авг./23/hardcore-python-zapuskaem-s-kod-s-pomoshchiu-cffi/</guid><category>cffi</category></item><item><title>Таинство стандартной библиотеки: functools.singledispatch</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./23/tainstvo-standartnoi-biblioteki-functoolssingledispatch/</link><description>&lt;p&gt;Стандартная поставка Python полна возможностями. 
Хочется упомянуть обобщенные функции. Если простыми словами, то это такие функции, где мы не думаем о типах аргументов, а просто пишем логику.  Например, (натянутый пример) оператор "+" - мы не думаем о аргументах, мы просто складывает два объекта.&lt;/p&gt;
&lt;p&gt;Для реализации обобщенных функций в Python 3 (начиная с 3.4) появился метод singledispatch в модуле functools.&lt;/p&gt;
&lt;p&gt;Подробней о этом механизме по ссылке - &lt;a href="https://www.python.org/dev/peps/pep-0443/"&gt;https://www.python.org/dev/peps/pep-0443/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 23 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-23:posts/2015/авг./23/tainstvo-standartnoi-biblioteki-functoolssingledispatch/</guid><category>functools</category></item><item><title>Полезные библиотеки: plot.ly (plotly)</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./22/poleznye-biblioteki-plotly-plotly/</link><description>&lt;p&gt;Понятное представление информации - это вечная задача. Причем она свойственна всем.&lt;/p&gt;
&lt;p&gt;Хочется упомянуть графики. Вот собрали мы данные, задача была не простая, а теперь надо их представить. Графики бывают разных типов, их очень много. Даже если какой-то график сделали, а как поделиться? Можно скинуть картинку, да только придется потом с "линейкой" вычислять значения, а можно пойти по другому пути - https://plot.ly/python/. &lt;/p&gt;
&lt;p&gt;ploy.ly предоставляет возможно создать динамический график, например, &lt;a href="https://plot.ly/python/dashboard/"&gt;https://plot.ly/python/dashboard/&lt;/a&gt;&lt;br /&gt;
plot.ly позволяет создавать самые разные графики, которые будут выглядеть как живые - можно будет методом тыка узнать значение графика в точке, покрутить, повертеть график.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 22 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-22:posts/2015/авг./22/poleznye-biblioteki-plotly-plotly/</guid><category>график</category><category>plotly</category></item><item><title>Полезные библиотеки: numpy</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./22/poleznye-biblioteki-numpy/</link><description>&lt;p&gt;NumPy — это библиотека языка Python, добавляющая поддержку больших многомерных массивов и матриц, вместе с большой библиотекой высокоуровневых (и очень быстрых) математических функций для операций с этими массивами.&lt;/p&gt;
&lt;p&gt;В чем же "фишка" NumPy вы можете спросить. &lt;/p&gt;
&lt;p&gt;Основным объектом NumPy является однородный многомерный массив (в numpy называется numpy.ndarray). Это многомерный массив элементов (обычно чисел), одного типа.&lt;/p&gt;
&lt;p&gt;Здесь можно подчеркнуть &lt;em&gt;одного типа&lt;/em&gt;. Эта существенная деталь позволяет заметно ускорить работу с такими объектами. Зная, что данный объект имеет только, скажем, целые числа, то не будут производится проверки типов. Плюс к этому - уменьшается общий объем памяти для хранения таких объектов.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonworld.ru/numpy/1.html"&gt;http://pythonworld.ru/numpy/1.html&lt;/a&gt;
&lt;a href="http://www.numpy.org/"&gt;http://www.numpy.org/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 22 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-22:posts/2015/авг./22/poleznye-biblioteki-numpy/</guid><category>numpy</category></item><item><title>Внутренности Python: зачем нужен GIL(Global interpreter lock)</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./21/vnutrennosti-python-zachem-nuzhen-gilglobal-interpreter-lock/</link><description>&lt;p&gt;Много хают GIL в Python, в этом видео вы узнаете насколько же он плох... или все-таки хорош?
&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=AWX4JnAnjBE'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 21 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-21:posts/2015/авг./21/vnutrennosti-python-zachem-nuzhen-gilglobal-interpreter-lock/</guid><category>GIL</category><category>видео</category></item><item><title>Python на службе народа: распознаем образы с помощью Raspberry Pi</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./21/python-na-sluzhbe-naroda-raspoznaem-obrazy-s-pomoshchiu-raspberry-pi/</link><description>&lt;p&gt;Raspberry Pi - это мини-компьютер, который имеет невысокую цену и при этом имеет богатые возможности.
Применение мини-компьютеров широкое, например, можно сделать камеру для дома - можете реализовать программку, которая будет следить за вашим маленьким ребенком и посылать вам сигнал, когда ребенок проснулся.&lt;/p&gt;
&lt;p&gt;&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=vRHoQVZLvoM)
[http://www.open-electronics.org/raspberry-pi-and-the-camera-pi-module-face-recognition-tutorial/](http://www.open-electronics.org/raspberry-pi-and-the-camera-pi-module-face-recognition-tutorial/)
[https://thinkrpi.wordpress.com/2013/05/22/opencv-and-camera-board-csi/](https://thinkrpi.wordpress.com/2013/05/22/opencv-and-camera-board-csi/'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 21 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-21:posts/2015/авг./21/python-na-sluzhbe-naroda-raspoznaem-obrazy-s-pomoshchiu-raspberry-pi/</guid><category>raspberry pi</category><category>видео</category><category>польза</category></item><item><title>Интересные концепции: Трансдьюсеры</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./20/interesnye-kontseptsii-transdiusery/</link><description>&lt;p&gt;Трансдьюсеры — это попытка переосмыслить операции над коллекциями, найти в них общую идею и принцип, научиться совмещать вместе несколько операций для их дальнейшего переиспользования.&lt;/p&gt;
&lt;p&gt;&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=ANZOvcYPagU)
[!embedlycard](https://www.youtube.com/watch?t=1080&amp;v=VTEfb5ojOzA'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 20 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-20:posts/2015/авг./20/interesnye-kontseptsii-transdiusery/</guid><category>видео</category><category>трансдьюсер</category></item><item><title>Анонс встречи №2 сообщества PyNSK</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./20/anons-vstrechi-2-soobshchestva-pynsk/</link><description>&lt;p&gt;Внимание внимание внимание, в середине сентября, а именно, 13 сентября в 13 часов пройдет встреча Python-сообщества PyNSK.&lt;/p&gt;
&lt;p&gt;Подробности по ссылке - &lt;a href="https://vk.com/pynsk_13_09_2015"&gt;https://vk.com/pynsk_13_09_2015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;На встрече вас ожидает два полноценных доклада и один мини-доклад:&lt;/p&gt;
&lt;p&gt;Доклад Игоря Старикова (основатель Python сайта &lt;a href="http://pythonz.net/"&gt;http://pythonz.net/&lt;/a&gt;) - "Разработчик разработчику: Азбука вежливости"&lt;/p&gt;
&lt;p&gt;Доклад Артёма Попова &lt;a href="https://vk.com/id42320764"&gt;https://vk.com/id42320764&lt;/a&gt; - "Python в музыке. osc, midi и asyncio"&lt;/p&gt;
&lt;p&gt;Мини-доклад Алесандра Сапронова (&lt;a href="https://vk.com/sapronov.alexander"&gt;https://vk.com/sapronov.alexander&lt;/a&gt;), который расскажет о новостях из мира Python: "Commit ускоривший Python 2.7.11 на 30% и новое в Python 3.5"&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 20 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-20:posts/2015/авг./20/anons-vstrechi-2-soobshchestva-pynsk/</guid></item><item><title>Таинство стандартной библиотеки: functools.partial</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./20/tainstvo-standartnoi-biblioteki-functoolspartial/</link><description>&lt;p&gt;Представим, написали мы функцию:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;super_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...........&lt;/span&gt;
&lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="n"&gt;run_server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Но вот беда, первый аргумент - имя сервера у вас уже есть. А второй, ip сервера, вы получите от пользователя, а функцию уже надо вызвать. Можно, конечно, дождаться когда будет два аргумента, тогда и запустить. А можно пойти по другому пути - воспользоваться механизмом каррирования - такое страшное слово. &lt;/p&gt;
&lt;p&gt;Каррирование - преобразование функции от (предположим) двух аргументов в функцию от первого аргумента, возвращающую функцию, результат вызова которой со вторым агрументом эквивалентен вызову первоначальной функции с упомянутыми аргументами.&lt;/p&gt;
&lt;p&gt;Мощный механизм, который нам и поможет. Пишем&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;

&lt;span class="n"&gt;my_func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;super_function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;My super server&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;....&lt;/span&gt;
&lt;span class="o"&gt;....&lt;/span&gt;
&lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;my_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/functools.html"&gt;https://docs.python.org/3.4/library/functools.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 20 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-20:posts/2015/авг./20/tainstvo-standartnoi-biblioteki-functoolspartial/</guid><category>functools</category></item><item><title>Полезные инструменты: gunicorn</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./19/poleznye-instrumenty-gunicorn/</link><description>&lt;p&gt;Вот вы написали web-проект, теперь надо его опубликовать на хостинге (или у себя на машине) (задеплоить). Начинаете жадно мучать гугл странными запросами. &lt;/p&gt;
&lt;p&gt;И вот наконец-то доходите до слов - uwsgi и gunicorn. Это серверы, которые с одной стороны предоставляют пользователям доступ к вашему проекту(сайтику), а с другой - общаются с вашим Python кодом. &lt;/p&gt;
&lt;p&gt;Стоит сказать, что gunicorn это WSGI HTTP сервер, написанный на питоне и легкий в настройке. Среди заявленных возможностей:&lt;/p&gt;
&lt;p&gt;поддержка WSGI, Django и Paster
async, sync worker
балансировка нагрузки через pre-fork и shared socket
разные хуки для расширение возможностей
Этот инструмент простой для понимания. Рекомендуем его использовать.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gunicorn.org/"&gt;http://gunicorn.org/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 19 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-19:posts/2015/авг./19/poleznye-instrumenty-gunicorn/</guid><category>gunicorn</category></item><item><title>Извлечение информации: парсинг дат/времени</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./19/izvlechenie-informatsii-parsing-datvremeni/</link><description>&lt;p&gt;Извлечение информации из текста/web-страниц сопряжено с эвристиками. 
Одна из проблем, с которой сталкиваются разработчики - как парсить даты. Даты можно написать 100 и одним способом:
tomorrow, а еще 4/4/80 или March 5th, 1980. И какой код писать, чтобы понять эти даты?&lt;/p&gt;
&lt;p&gt;К счастью, код уже написан - &lt;a href="https://github.com/bear/parsedatetime"&gt;https://github.com/bear/parsedatetime&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Данная библиотека позволяет спарсить время в самых различных форматах.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 19 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-19:posts/2015/авг./19/izvlechenie-informatsii-parsing-datvremeni/</guid><category>парсинг</category></item><item><title>Статическая типизация в Python: сила опциональной типизации</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./18/staticheskaia-tipizatsiia-v-python-sila-optsionalnoi-tipizatsii/</link><description>&lt;p&gt;Не секрет, что Python (CPython) - динамически типизируемый язык (все типы выясняются во время выполнения программы). Это как дар так и проклятие. С одной стороны - можно быстрее писать программы, с другой - тяжелее найти ошибки. При этом, если была бы статическая типизация - уже на этапе компиляции мы знали бы где мы затупили с типами.&lt;/p&gt;
&lt;p&gt;В этом видео рассказывается, как же можно использовать опциональную статическую типизацию в Python
&lt;a class='embedly-card' data-card-chrome='0' href='https://www.youtube.com/watch?v=NdX0-FnypjE'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 18 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-18:posts/2015/авг./18/staticheskaia-tipizatsiia-v-python-sila-optsionalnoi-tipizatsii/</guid><category>видео</category><category>типизация</category><category>статическая типизация</category></item><item><title>Тесты тесты тесты: nose</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./18/testy-testy-testy-nose/</link><description>&lt;p&gt;nose — это инструмент для прогона тестов посредством unittest (и doctest, с ключом --with-doctest). Имеет также собственное API, использовать которое необязательно. 
nose автоматически собирает тесты из файлов вида test_*, достаточно умен, чтобы заглянуть в папочку tests при наличии таковой, умеет измерять покрытие кода (code coverage) при помощи coverage.py (--with-coverage). Также можно запустить только тесты, которые отвалились в последний прогон (--failed).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nose.readthedocs.org/en/latest/"&gt;https://nose.readthedocs.org/en/latest/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 18 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-18:posts/2015/авг./18/testy-testy-testy-nose/</guid><category>тест</category><category>nose</category></item><item><title>Полезные инструменты: Pycharm</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./17/poleznye-instrumenty-pycharm/</link><description>&lt;p&gt;Pycharm - это IDE специализированная под Python разработку.&lt;/p&gt;
&lt;p&gt;Возможности этого редактора кода захватывают:
- Статический анализ кода, подсветка синтаксиса и ошибок.
- Рефакторинг: переименование, извлечение метода, введение переменной, введение константы, подъём и спуск метода и т. д.
- Инструменты для веб-разработки с использованием фреймворка Django
- Встроенный отладчик для Python
- Встроенные инструменты для юнит-тестирования
- Поддержка систем контроля версий (Git, svn и другие)
- По-мимо этого, Pycharm поддержку множество модулей, например, IPython встроен в редактор. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.jetbrains.com/pycharm/"&gt;https://www.jetbrains.com/pycharm/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 17 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-17:posts/2015/авг./17/poleznye-instrumenty-pycharm/</guid><category>ide</category><category>pycharm</category></item><item><title>Синтаксис Python: изменяемые и неизменяемые типы данных</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./17/sintaksis-python-izmeniaemye-i-neizmeniaemye-tipy-dannykh/</link><description>&lt;p&gt;Все типы данных в Python относятся к одной из 2-х категорий: изменяемые (mutable) и неизменяемые (unmutable). Многие из предопределённых типов данных Python — это типы неизменяемых объектов: числовые данные (int, float, complex), символьные строки (class 'str'), кортежи (tuple). Другие типы определены как изменяемые: списки (list), множества (set), словари (dict). Вновь определяемые пользователем типы (классы) могут быть определены как неизменяемые или изменяемые. Изменяемость объектов определённого типа является принципиально важной характеристикой, определяющей, может ли объект такого типа выступать в качестве ключа для словарей (dict) или нет.&lt;/p&gt;
&lt;p&gt;Подробнее по ссылке - &lt;a href="https://www.ibm.com/developerworks/ru/library/l-python_details_02/"&gt;https://www.ibm.com/developerworks/ru/library/l-python_details_02/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 17 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-17:posts/2015/авг./17/sintaksis-python-izmeniaemye-i-neizmeniaemye-tipy-dannykh/</guid><category>типы данных</category></item><item><title>Hardcore Python: Cython</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./16/hardcore-python-cython/</link><description>&lt;p&gt;Cython — язык программирования, упрощающий написание модулей С/С++ кода для Python. Кроме стандартного синтаксиса Python, поддерживаются:&lt;/p&gt;
&lt;p&gt;Прямой вызов функций и методов С/С++ из кода на Cython;
Строгая типизация переменных, классов, атрибутов классов.&lt;/p&gt;
&lt;p&gt;Код Cython преобразуется в С/С++ код для последующей компиляции и впоследствии может использоваться как расширение стандартного Python или как независимое приложение со встроенной библиотекой выполнения Cython.&lt;/p&gt;
&lt;p&gt;Программирование на Cyhton не очень отличается от Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cdef&lt;/span&gt; &lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ackermann:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ackermann&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В этом коде указаны типы, что делать не обязательно (тогда и прироста не будет толком)
Типы в Cython - Си-шные, т.е. каких-то сложных Python-типов вы не найдете.&lt;/p&gt;
&lt;p&gt;Хорошее применение языка - связка с C/C++ кодом - оно происходит в разы быстрее, чем в CPython и PyPi. Скорость исполнения программы также выше (может достигать сотен раз).  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://cython.org/"&gt;http://cython.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.wikiwand.com/ru/Cython"&gt;https://www.wikiwand.com/ru/Cython&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 16 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-16:posts/2015/авг./16/hardcore-python-cython/</guid><category>cython</category><category>оптимизация</category></item><item><title>Python и асинхронные задачи</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./16/python-i-asinkhronnye-zadachi/</link><description>&lt;p&gt;Celery — распределенная очередь заданий
И так, что же умеет Celery:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Выполнять задания асинхронно или синхронно&lt;/li&gt;
&lt;li&gt;Выполнять периодические задания(умная замена crond)&lt;/li&gt;
&lt;li&gt;Выполнять отложенные задания&lt;/li&gt;
&lt;li&gt;Распределенное выполнение (может быть запущен на N серверах)&lt;/li&gt;
&lt;li&gt;В пределах одного worker'а возможно конкурентное выполнение нескольких задач(одновременно)&lt;/li&gt;
&lt;li&gt;Выполнять задание повторно, если вылез exception&lt;/li&gt;
&lt;li&gt;Ограничивать количество заданий в единицу времени(rate limit, для задания или глобально)&lt;/li&gt;
&lt;li&gt;Routing заданий(какому worker'у что делать)&lt;/li&gt;
&lt;li&gt;Несложно мониторить выполнение заданий&lt;/li&gt;
&lt;li&gt;Выполнять подзадания&lt;/li&gt;
&lt;li&gt;Присылать отчеты об exception'ах на email&lt;/li&gt;
&lt;li&gt;Проверять выполнилось ли задание(удобно для построения Ajax приложений, где юзер ждет факта завершения)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Применение очередей задач широкое - если у вас есть задачи, которые можно выполнить не прям сейчас, а чуть позже - то стоит использовать. Примеры таких задач - парсинг RSS, отправка Email.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.celeryproject.org/"&gt;http://www.celeryproject.org/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 16 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-16:posts/2015/авг./16/python-i-asinkhronnye-zadachi/</guid><category>celery</category></item><item><title>Рисование графиков на Python</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./15/risovanie-grafikov-na-python/</link><description>&lt;p&gt;Графики бывают совсем разные. Де-факто стандартом в питоне для построения графиков является matplotlib. Это такой комбайн, который умеет очень много, даже 3Д графики. &lt;/p&gt;
&lt;p&gt;Matplotlib написан и поддерживался в основном Джоном Хантером (англ. John Hunter) и распространяется на условиях BSD-подобной лицензии. Генерируемые в различных форматах изображения могут быть использованы в интерактивной графике, в научных публикациях, графическом интерфейсе пользователя, веб-приложениях, где требуется построение диаграмм.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://matplotlib.org/"&gt;http://matplotlib.org/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 15 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-15:posts/2015/авг./15/risovanie-grafikov-na-python/</guid><category>график</category><category>matplotlib</category></item><item><title>Python в играх: PyGame</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./15/python-v-igrakh-pygame/</link><description>&lt;p&gt;Pygame - это кроссплатформенная библиотека языка Python, предназначенная для написания компьютерных игр и мультимедиа приложений.&lt;/p&gt;
&lt;p&gt;Для знакомства с возможностями PyGame ссылки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/130726/"&gt;http://habrahabr.ru/post/130726/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/130726/"&gt;http://habrahabr.ru/post/130726/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/164229/"&gt;http://habrahabr.ru/post/164229/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/193888/"&gt;http://habrahabr.ru/post/193888/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pygame.org/"&gt;http://www.pygame.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 15 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-15:posts/2015/авг./15/python-v-igrakh-pygame/</guid><category>pygame</category></item><item><title>Python в играх: где используется Python?</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./14/python-v-igrakh-gde-ispolzuetsia-python/</link><description>&lt;p&gt;Сегодня вашему вниманию представляется статья и небольшая инфографика, которая покажет вам на конкретных примерах, что Python столь же эффективен в разработке игр, как и в других областях.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tproger.ru/articles/python-powered-games/"&gt;http://tproger.ru/articles/python-powered-games/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 14 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-14:posts/2015/авг./14/python-v-igrakh-gde-ispolzuetsia-python/</guid><category>игры</category></item><item><title>Python на службе народа: Я выключил духовку?</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./14/python-na-sluzhbe-naroda-ia-vykliuchil-dukhovku/</link><description>&lt;p&gt;Программирование должно упрощать жизнь. Распознавание образов это интересная задача, но далеко не всегда надо обучать нейронную сеть, вычислять на видеокарте.&lt;/p&gt;
&lt;p&gt;OpenCV это библиотека компьютерного зрения. Которая ОЧЕНЬ много умеет чего. По ссылке вы сможете найти пример использование OpenCV для определения "Выключил ли я духовку?"&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kazuar.github.io/light-detection-opencv/"&gt;http://kazuar.github.io/light-detection-opencv/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 14 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-14:posts/2015/авг./14/python-na-sluzhbe-naroda-ia-vykliuchil-dukhovku/</guid><category>opencv</category></item><item><title>Python оптимизации: сверхоптимизация кода на Python</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./13/python-optimizatsii-sverkhoptimizatsiia-koda-na-python/</link><description>&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/K3qL3NqZDcE?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 13 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-13:posts/2015/авг./13/python-optimizatsii-sverkhoptimizatsiia-koda-na-python/</guid><category>hardcore</category><category>оптимизация</category><category>видео</category></item><item><title>Опыт разработчиков: "Перестаньте писать классы"</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./13/opyt-razrabotchikov-perestante-pisat-klassy/</link><description>&lt;p&gt;Признак того, что объект не должен быть классом — если в нём всего 2 метода, и один из них — инициализация, &lt;code&gt;__init__&lt;/code&gt;. Каждый раз видя это, подумайте: «наверное, мне нужна просто одна функция».&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/140581/"&gt;http://habrahabr.ru/post/140581/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/143620/"&gt;http://habrahabr.ru/post/143620/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 13 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-13:posts/2015/авг./13/opyt-razrabotchikov-perestante-pisat-klassy/</guid></item><item><title>Парсинг и Python: mechanize</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./12/parsing-i-python-mechanize/</link><description>&lt;p&gt;Для сбора данных с Web-страниц в Python существует библиотека mechanize, автоматизирующая взаимодействие с Web-сайтами. Часто используемая совместно с ней библиотека Beautiful Soup помогает понять тот «почти-HTML» код, который обычно находится на Web-сайтах.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/ru/library/l-python-mechanize-beautiful-soup/"&gt;http://www.ibm.com/developerworks/ru/library/l-python-mechanize-beautiful-soup/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 12 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-12:posts/2015/авг./12/parsing-i-python-mechanize/</guid><category>парсинг</category><category>mechanize</category></item><item><title>Таинство стандартной библиотеки: примеры для asyncio - aiohttp</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./12/tainstvo-standartnoi-biblioteki-primery-dlia-asyncio-aiohttp/</link><description>&lt;p&gt;Asyncio - это модуль содержащий инфраструктуру пригодную для написания асинхронных сетевых приложений. Благодаря концепции сопрограмм (coroutines), код асинхронного приложения прост для понимания и поддержки. &lt;/p&gt;
&lt;p&gt;Экосистема развивается не по дням, а по часам. Стоит обратить внимание на развитие этого направления современного Python&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://sysdev.me/python-asyncio/"&gt;http://sysdev.me/python-asyncio/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/asyncio.html"&gt;https://docs.python.org/3/library/asyncio.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/asyncio-dev.html"&gt;https://docs.python.org/3/library/asyncio-dev.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 12 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-12:posts/2015/авг./12/tainstvo-standartnoi-biblioteki-primery-dlia-asyncio-aiohttp/</guid><category>asyncio</category><category>aiohttp</category></item><item><title>Тесты тесты тесты: что такое фикстура (fixture)?</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./11/testy-testy-testy-chto-takoe-fikstura-fixture/</link><description>&lt;p&gt;При написании тестов не редка ситуация, когда надо иметь фиксированное воспроизводимое много раз состояние программы. Например, такая-то кнопочка нажата, такой-то класс содержит такие-то значения.&lt;/p&gt;
&lt;p&gt;Чтобы не приходилось каждый раз вручную создавать подобное состояние программы используются fixture (фикстуры). 
Фикстуры позволяют сохранить состояние системы в файл, а потом его от туда загрузить. &lt;/p&gt;
&lt;p&gt;По-мимо тестов, фикстуры применяются для создания начального состояния системы. Например, есть проект, который использует базу данных(БД). И возникает задача развернуть проект на новом компьютере. Можно перетаскивать БД и чистить от лишнего. А можно сохранить первичное состояние в файле и затем его подгрузить.&lt;/p&gt;
&lt;p&gt;Ссылки для погружения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://farmdev.com/projects/fixture/"&gt;http://farmdev.com/projects/fixture/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythontesting.net/framework/pytest/pytest-fixtures-easy-example/"&gt;http://pythontesting.net/framework/pytest/pytest-fixtures-easy-example/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.djangoproject.com/en/1.8/howto/initial-data/"&gt;https://docs.djangoproject.com/en/1.8/howto/initial-data/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 11 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-11:posts/2015/авг./11/testy-testy-testy-chto-takoe-fikstura-fixture/</guid><category>тест</category><category>fixture</category></item><item><title>Тесты тесты тесты: пропускаем тесты в pytest по условию</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./11/testy-testy-testy-propuskaem-testy-v-pytest-po-usloviiu/</link><description>&lt;p&gt;Тесты не всегда универсальны. Например, в Windows надо дергать одну программу, в Linux другую. Чтобы реализовать такую логику в pytest можно воспользоваться - &lt;code&gt;skipif&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="nd"&gt;@pytest.mark.skipif&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version_info&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;reason&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;requires python3.3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Вот такой пример демонстрирует как можно пропустить тест, если запуск происходит в Python версии ниже 3.3.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 11 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-11:posts/2015/авг./11/testy-testy-testy-propuskaem-testy-v-pytest-po-usloviiu/</guid><category>тест</category><category>pytest</category></item><item><title>Установка библиотек в Python</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./10/ustanovka-bibliotek-v-python/</link><description>&lt;p&gt;Репозиторий pypi содержит более 62к модулей. Такое количество готовых инструментов, в дополнение к богатой стандартной поставке, позволяет заметно упростить разработку новых проектов. Вот только новички сталкиваются с проблемой установки этих самых модулей. &lt;/p&gt;
&lt;p&gt;Стандартным способом установки новых модулей является pip (и easy_install). pip &lt;a href="https://pip.pypa.io/en/latest/index.html"&gt;https://pip.pypa.io/en/latest/index.html&lt;/a&gt; это инструмент, который упрощает управление модулями.&lt;/p&gt;
&lt;p&gt;Вы можете установить модуль, например numpy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install numpy
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Удалить, его же:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip unistall numpy
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Можете получить список библиотеки уже установленных - &lt;code&gt;pip list&lt;/code&gt;
Это не весь список команд, но и его достаточно для установки библиотек буквально в 1 команду.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 10 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-10:posts/2015/авг./10/ustanovka-bibliotek-v-python/</guid><category>pip</category><category>pypi</category></item><item><title>Магические методы в Python</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./10/magicheskie-metody-v-python/</link><description>&lt;p&gt;Статья от  Rafe Kettler.&lt;/p&gt;
&lt;p&gt;Что такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, &lt;strong&gt;init&lt;/strong&gt; или &lt;strong&gt;lt&lt;/strong&gt;). Ещё, они не так хорошо документированны, как хотелось бы. Все магические методы описаны в документации, но весьма беспорядочно и почти безо всякой организации. Поэтому, чтобы исправить то, что я воспринимаю как недостаток документации Питона, я собираюсь предоставить больше информации о магических методах, написанной на понятном языке и обильно снабжённой примерами. Надеюсь, это руководство вам понравится. Используйте его как обучающий материал, памятку или полное описание.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://habrahabr.ru/post/186608/"&gt;http://habrahabr.ru/post/186608/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 10 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-10:posts/2015/авг./10/magicheskie-metody-v-python/</guid><category>стандартная библиотека</category></item><item><title>Таинство стандартной библиотеки: collections</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./09/tainstvo-standartnoi-biblioteki-collections/</link><description>&lt;p&gt;Модуль collections - предоставляет специализированные типы данных, на основе словарей, кортежей, множеств, списков. Этот модуль хорошо себя показывает при частой работе со словарями и списками. 
Например, данный модуль предоставляет возможность посчитать n наиболее часто встречающихся элементов, в порядке убывания встречаемости. Есть в этом модуле и словарь, который помнит порядок ключей. А еще есть структура, которая позволяет создать объект ведущий себя как кортеж, с тем дополнением, что каждому элементу присваивается имя, по которому можно в дальнейшем получать доступ.&lt;/p&gt;
&lt;p&gt;Заинтересовал? 
Вот ссылки для дальнейшего погружения в тему:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3.5/library/collections.html"&gt;https://docs.python.org/3.5/library/collections.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/moduli/modul-collections.html"&gt;http://pythonworld.ru/moduli/modul-collections.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 09 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-09:posts/2015/авг./09/tainstvo-standartnoi-biblioteki-collections/</guid></item><item><title>Таинство стандартной библиотеки: datetime и calendar</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./09/tainstvo-standartnoi-biblioteki-datetime-i-calendar/</link><description>&lt;p&gt;Стандартная поставка Python содержит множество инструментов для решения задач. Например, для работы с датами отлично себя показывают datetime и calendar&lt;/p&gt;
&lt;p&gt;Модуль datetime предоставляет классы для обработки времени и даты разными способами. Поддерживается и стандартный способ представления времени, однако больший упор сделан на простоту манипулирования датой, временем и их частями.&lt;/p&gt;
&lt;p&gt;Модуль calendar позволяет напечатать себе календарик (а также содержит некоторые другие полезные функции для работы с календарями). &lt;/p&gt;
&lt;p&gt;Возможности этих модулей обширны. Стоит их рассмотреть внимательно.
Для этого приведем ссылки:&lt;/p&gt;
&lt;p&gt;datetime:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/datetime.html"&gt;https://docs.python.org/2/library/datetime.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/moduli/modul-datetime.html"&gt;http://pythonworld.ru/moduli/modul-datetime.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pymotw.com/2/datetime/"&gt;http://pymotw.com/2/datetime/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;calendar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/library/calendar.html"&gt;https://docs.python.org/2/library/calendar.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pymotw.com/2/calendar/"&gt;http://pymotw.com/2/calendar/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 09 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-09:posts/2015/авг./09/tainstvo-standartnoi-biblioteki-datetime-i-calendar/</guid></item><item><title>Python и real-time web приложение</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./08/python-i-real-time-web-prilozhenie/</link><description>&lt;p&gt;Далеко не всегда требуется тащить мощный Django или другой фреймворк. Бывает достаточно небольшого количества чистого Python кода и базы данных.
Посмотрим, как имея всего эти 2 элемента написать приложение.
&lt;a class='embedly-card' data-card-chrome='0' href='https://www.youtube.com/watch?v=PsorlkAF83s'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 08 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-08:posts/2015/авг./08/python-i-real-time-web-prilozhenie/</guid><category>видео</category><category>hardcore</category><category>real-time</category><category>web</category></item><item><title>Python + GUI == PyQt</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./08/python-gui-pyqt/</link><description>&lt;p&gt;Qt - это инструментарий для разработки на C++, который предоставляет огромный спектр возможностей: от рисования GUI, до написания низкоуровневых серверов. 
Часто Qt применяют для создания GUI, в том числе в интерактивном режиме - можно перемещать виджеты на формы.
Qt имеет отличную докумементацию, а также имеет привязку для Python - PyQt и PySide. (вторая еще с Qt5 не умеет работать)&lt;/p&gt;
&lt;p&gt;Используя PyQt можно нарисовать формочку в редакторе, а затем буквально одной строчкой начать писать логику.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.python.org/moin/PyQt"&gt;https://wiki.python.org/moin/PyQt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wiki.python.su/Документации/ВведениеВСредуPyQt4"&gt;http://wiki.python.su/Документации/ВведениеВСредуPyQt4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 08 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-08:posts/2015/авг./08/python-gui-pyqt/</guid></item><item><title>Python как средство для определения "хорошо/плохо"</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./07/python-kak-sredstvo-dlia-opredeleniia-khoroshoplokho/</link><description>&lt;p&gt;Информации очень много. Хорошо бы уметь ее фильтровать. Хочется упомянуть такое средство фильтрации как анализ тональности. Это даже не фильтрация, но можно применять как фильтр.&lt;/p&gt;
&lt;p&gt;Sentiment analysis (по-русски, анализ тональности) — это область компьютерной лингвистики, которая занимается изучением мнений и эмоций в текстовых документах. &lt;/p&gt;
&lt;p&gt;С помощью анализа тональности можно определить, что текст N интересный, а текст M неинтересный - причем это сделает компьютер за вас.&lt;/p&gt;
&lt;p&gt;Для погружения в эту тему стоит почитать эти ссылки:
- &lt;a href="http://habrahabr.ru/post/149605/"&gt;http://habrahabr.ru/post/149605/&lt;/a&gt;
- &lt;a href="http://habrahabr.ru/post/263171/"&gt;http://habrahabr.ru/post/263171/&lt;/a&gt;
- &lt;a href="http://habrahabr.ru/post/197890/"&gt;http://habrahabr.ru/post/197890/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 07 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-07:posts/2015/авг./07/python-kak-sredstvo-dlia-opredeleniia-khoroshoplokho/</guid></item><item><title>Утилиты написанные на Python: youtube-dl</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./07/utility-napisannye-na-python-youtube-dl/</link><description>&lt;p&gt;youtube-dl (https://github.com/rg3/youtube-dl/)
- это очень популярный скрипт для выгрузки видео с сервиса Youtube (, Vimeo и других). Данная утилита позволяет очень легко выдернуть видео со страницы ютьюб. 
Множество настроек позволяют в том числе выдернуть субтитры, узнать длительность видео и многие другие параметры.&lt;/p&gt;
&lt;p&gt;Данную утилиту можно применить следующим образом: если у вас есть ряд каналов, которые вы смотрите регулярно, то часто задаетесь вопросом "Вышло новое видео или нет?".
Чтобы не тыкаться по 10 раз на дню на сайт (плюс к этому, "котики" могут отвлечь на несколько часов), вы можете соединить несколько сервисов вместе и новые видео будут автоматически попадать к вам на компьютер. &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 07 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-07:posts/2015/авг./07/utility-napisannye-na-python-youtube-dl/</guid></item><item><title>Что такое PEP?</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./06/chto-takoe-pep/</link><description>&lt;p&gt;Развитие языка Python происходит согласно чётко регламентированному процессу создания, обсуждения, отбора и реализации документов PEP.
PEP - Python Enhancement Proposal - это предложения по развитию питона
&lt;a href="https://www.python.org/dev/peps/"&gt;https://www.python.org/dev/peps/&lt;/a&gt;
Процесс PEP является основным механизмом для предложения новых возможностей и для документирования проектных решений, которые прошли в Python.&lt;/p&gt;
&lt;p&gt;Самым известным PEP является PEP8 - это свод рекомендаций в оформлению кода. Рекомендации написаны кровью из глаз программистов.
&lt;a href="https://www.python.org/dev/peps/pep-0008/"&gt;https://www.python.org/dev/peps/pep-0008/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 06 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-06:posts/2015/авг./06/chto-takoe-pep/</guid><category>pep</category><category>стандарт</category></item><item><title>Python и базы данных: много баз - много модулей или один?</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./06/python-i-bazy-dannykh-mnogo-baz-mnogo-modulei-ili-odin/</link><description>&lt;p&gt;Без баз данных (БД) в современной разработке редко обходится. Питон не обделен и имеет множество модулей для работы с базами данных. Есть и специализированные, например, pymongo - модуль для MongoDB, есть и более обширные - sqlalchemy, PonyORB.&lt;/p&gt;
&lt;p&gt;sqlalchemy - это &lt;a href="https://www.wikiwand.com/ru/ORM"&gt;ORM&lt;/a&gt; для различных БД. Если просто, то это инструмент, написать структуру данных и работать с ней, а "алхимия" будет самостоятельно сохранять/подгружать из БД данные.
sqlalchemy умеет работать со всеми популярными реляционными БД.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 06 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-06:posts/2015/авг./06/python-i-bazy-dannykh-mnogo-baz-mnogo-modulei-ili-odin/</guid><category>sqlalchemy</category><category>БД</category></item><item><title>Python и интересный парсинг сайтов</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./05/python-i-interesnyi-parsing-saitov/</link><description>&lt;p&gt;Излечение информации со страниц может быть интересным. Рекомендуем к просмотру видео
&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=hj-8l3AejNc'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 05 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-05:posts/2015/авг./05/python-i-interesnyi-parsing-saitov/</guid><category>видео</category><category>парсинг</category></item><item><title>Bottle с Python</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./05/bottle-s-python/</link><description>&lt;p&gt;bottle - это веб-фреймворк для Python. Отличительной особенностью этого фреймворка является простота - исходный код занимает один файл. Несмотря на свою минималистичность, Bottle предоставляет довольно широкие возможности, которых на 100% хватает для мелких и средних проектов.
Чтобы стартануть изучение достаточно написать:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;bottle&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;route&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;

&lt;span class="nd"&gt;@route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/hello/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;index&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;b&amp;gt;Hello {{name}}&amp;lt;/b&amp;gt;!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Это запустит web-приложение на 8080 порту, а по ссылке &lt;code&gt;http://127.0.0.1/hello/Alexander&lt;/code&gt; вы увидите Hello Alexander.
Очень просто.&lt;/p&gt;
&lt;p&gt;Дальнейшее изучение можно продолжить по ссылкам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bottlepy.org/docs/dev/index.html"&gt;http://bottlepy.org/docs/dev/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/221659/"&gt;http://habrahabr.ru/post/221659/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/250831/"&gt;http://habrahabr.ru/post/250831/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 05 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-05:posts/2015/авг./05/bottle-s-python/</guid><category>bottle</category><category>web</category></item><item><title>Тесты тесты тесты: модуль тестирования py.test</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./04/testy-testy-testy-modul-testirovaniia-pytest/</link><description>&lt;p&gt;Наряду с входящими в стандартную поставку питона средствами для тестирования, существуют и альтернативные инструменты, например, py.test. &lt;a href="http://pytest.org/"&gt;http://pytest.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;py.test имеет множество расширений, которые значительно упрощают написание тестов.
py.test имеет плагины для всех популярных web-фреймворков, с помощью плагинов позволяет кэшеировать результаты (успешных тестов), формировать отчеты в самых различных форматах.
А также имеет очень простую систему расширения и вы можете буквально за день написать свой плагин.
&lt;a class='embedly-card' data-card-chrome='0' href='http://pytest.org/latest/_static/pytest1.png'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 04 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-04:posts/2015/авг./04/testy-testy-testy-modul-testirovaniia-pytest/</guid><category>тест</category><category>unittest</category></item><item><title>Тесты тесты тесты: создание читаемых отчетов</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./04/testy-testy-testy-sozdanie-chitaemykh-otchetov/</link><description>&lt;p&gt;Тесты тесты тесты: создание читаемых отчетов&lt;/p&gt;
&lt;p&gt;Когда в вашей программе очень много тестов, то возникают проблемы с чтением отчетов (что сломалось, что корректно отработало). Для создания читаемых отчетов можно порекомендовать allure-framework. О этом фреймворке можно узнать в видео:
&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=d5SreR6dGnE'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/allure-framework"&gt;https://github.com/allure-framework&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 04 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-04:posts/2015/авг./04/testy-testy-testy-sozdanie-chitaemykh-otchetov/</guid><category>тест</category><category>test</category><category>отчет</category><category>видео</category></item><item><title>Синтаксис Python: конструкция switch</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./03/sintaksis-python-konstruktsiia-switch/</link><description>&lt;p&gt;Стоит упомянуть про конструкцию switch в Python. Такой конструкции в языке нет, однако, выкрутится можно. Часто рекомендуют писать множественные elif'ы, но можно сделать так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;switch_case&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You entered &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;an out of range number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Input a number between 1 and 3: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;switch_case&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В этом примере мы создаем словарь, а затем получаем значение по нужному нам ключу.&lt;/p&gt;
&lt;p&gt;Вот только этот подход не работает, когда значение switch'а вычисляется в динамике. (Например, если мы приветствуем/прощаемся какого-то пользователя). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В этом случае мы все также создаем словарь, но в качестве значений словаря прописываем функцию (в примере - lamdba функции). Затем получаем эту функцию словаря и вычисляем с аргументом.&lt;/p&gt;
&lt;p&gt;Еще способы реализации switch-case в Python:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/410695/"&gt;Recipe 410692: Readable switch construction without lambdas or dictionaries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/410695/"&gt;Recipe 410695: Exception-based Switch-Case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/181064/"&gt;Recipe 181064: Using a Dictionary in place of a ’switch’ statement&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 03 Aug 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-03:posts/2015/авг./03/sintaksis-python-konstruktsiia-switch/</guid></item><item><title>Синтаксис Python: трехместное выражение if/else</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./03/sintaksis-python-trekhmestnoe-vyrazhenie-ifelse/</link><description>&lt;p&gt;Сегодня хочется упомянуть о непонятной на первый взгляд конструкции - тернарная условная операция, или по-русски - трехместное выражение &lt;code&gt;if/else&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Представим, есть такой код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение &lt;code&gt;if/else&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;t&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;spam&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;t&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Синтаксис конструкции if-elif-else описан по ссылкам&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/tutorial/controlflow.html"&gt;https://docs.python.org/3/tutorial/controlflow.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/osnovy/instrukciya-if-elif-else-proverka-istinnosti-trexmestnoe-vyrazhenie-ifelse.html"&gt;http://pythonworld.ru/osnovy/instrukciya-if-elif-else-proverka-istinnosti-trexmestnoe-vyrazhenie-ifelse.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 03 Aug 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-03:posts/2015/авг./03/sintaksis-python-trekhmestnoe-vyrazhenie-ifelse/</guid><category>if</category><category>синтаксис</category></item><item><title>Рисование svg графиков</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./02/risovanie-svg-grafikov/</link><description>&lt;p&gt;Для рисования векторных графиков (svg) подойдет библиотека pygal - &lt;a href="http://pygal.org/"&gt;http://pygal.org/&lt;/a&gt; 
Данный модуль предоставляет широкий спектр возможностей, в частности можно нарисовать:&lt;/p&gt;
&lt;p&gt;Столбчатые диаграммы
Линейные диаграммы
XY диаграммы
Круговые диаграммы
Лепестковые диаграммы
и другие&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 02 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-02:posts/2015/авг./02/risovanie-svg-grafikov/</guid><category>график</category><category>svg</category></item><item><title>Статистический модуль в стандартной библиотеке</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./02/statisticheskii-modul-v-standartnoi-biblioteke/</link><description>&lt;p&gt;Статистический модуль теперь есть в стандартной библиотеке.
Начиная с версии 3.4 в стандартной поставке Python появилось более продвинутое средство для работы с данными. Теперь нет необходимости писать руками методы average, median (вычисление среднего и медианы)  и других. Ознакомьтесь с возможностями стандартного модуля:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/library/statistics.html"&gt;https://docs.python.org/3/library/statistics.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sun, 02 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-02:posts/2015/авг./02/statisticheskii-modul-v-standartnoi-biblioteke/</guid><category>статистика</category></item><item><title>Python + winapi</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./01/python-winapi/</link><description>&lt;p&gt;Пишите под windows, да еще и с Win API? Python здесь тоже может помочь, ведь для него есть библиотека pywin32 (http://sourceforge.net/projects/pywin32/). Данная библиотека предоставляет все базовые примитивы для работы с WinAPI.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 01 Aug 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-01:posts/2015/авг./01/python-winapi/</guid><category>winapi</category></item><item><title>click</title><link>http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./01/click/</link><description>&lt;p&gt;Библиотека click (&lt;a href="http://click.pocoo.org/4/"&gt;http://click.pocoo.org/4/&lt;/a&gt;) позволяет с минимальными усилиями создать интерфейс командной строки. 
Создаете функцию, добавляете пару декораторов и готово.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;click&lt;/span&gt;

&lt;span class="nd"&gt;@click.command&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nd"&gt;@click.option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--count&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Number of greetings.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@click.option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prompt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Your name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;The person to greet.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
     &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;А как вы создаете командные интерфейсы?&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 01 Aug 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-08-01:posts/2015/авг./01/click/</guid></item><item><title>JSON DSL - JSL</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/31/json-dsl-jsl/</link><description>&lt;p&gt;Если вы широко используете JSON в своем проекте, то вам будет интересен DSL - JSL.
JSL позволяет описывать модели, почти в какой-нибудь ORM, создавать объекты по этим моделям и как-то с ними работать.
Интересный проект.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/aromanovich/jsl"&gt;https://github.com/aromanovich/jsl&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 31 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-31:posts/2015/июля/31/json-dsl-jsl/</guid><category>dsl</category><category>json</category></item><item><title>Python - язык общего назначения</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/31/python-iazyk-obshchego-naznacheniia/</link><description>&lt;p&gt;Python - язык общего назначения, может применяться где угодно. Не верите? На странице &lt;a href="https://www.python.org/about/success/"&gt;https://www.python.org/about/success/&lt;/a&gt; представлены сферы и названия компаний, которые применяют этот язык.&lt;/p&gt;
&lt;p&gt;Впечатляет.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 31 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-31:posts/2015/июля/31/python-iazyk-obshchego-naznacheniia/</guid></item><item><title>Python и real-time?</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/30/python-i-real-time/</link><description>&lt;p&gt;Возможно!&lt;br /&gt;
Рассказ "Управление памятью в real-time приложениях Python"  Антона Патрушева покажет как можно писать Python приложения с максимально быстрым откликом.
&lt;a href="https://events.yandex.ru/lib/talks/2075/"&gt;https://events.yandex.ru/lib/talks/2075/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 30 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-30:posts/2015/июля/30/python-i-real-time/</guid><category>интерпретатор</category><category>real-time</category></item><item><title>Сравнение R и Python</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/30/sravnenie-r-i-python/</link><description>&lt;p&gt;В последнее время любят сравнивать Python и R. Так давайте же почитаем сравнение этих двух языков. 
&lt;a href="http://blog.dominodatalab.com/comparing-python-and-r-for-data-science/"&gt;http://blog.dominodatalab.com/comparing-python-and-r-for-data-science/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 30 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-30:posts/2015/июля/30/sravnenie-r-i-python/</guid><category>R</category><category>python</category><category>сравнение</category></item><item><title>Парсинг с помощью asyncio</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/29/parsing-s-pomoshchiu-asyncio/</link><description>&lt;p&gt;Парсинг сайтов это вечная задача. Сайтов много, данных много и все они разные.
Для задач парсинга существует великое разнообразие инструментов.&lt;/p&gt;
&lt;p&gt;В Python 3-ей версии появился стандартный модуль для создания асинхронных программ. И грех не воспользоваться данной возможностью.&lt;/p&gt;
&lt;p&gt;Примером парсинга на asyncio может послужить эта статья 
&lt;a href="http://olegwock.net/blog/python/byistryiy-parsing-na-python-s-pomoshhyu-asyncio/"&gt;http://olegwock.net/blog/python/byistryiy-parsing-na-python-s-pomoshhyu-asyncio/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 29 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-29:posts/2015/июля/29/parsing-s-pomoshchiu-asyncio/</guid><category>asyncio</category><category>парсинг</category></item><item><title>Django REST API</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/29/django-rest-api/</link><description>&lt;p&gt;Пишите web приложения? Тогда для вас не является новостью, что без API далеко не уедешь. &lt;/p&gt;
&lt;p&gt;Для фреймворка django существует несколько способов создать API за пару минут, да еще и с документацией.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tomchristie/django-rest-framework"&gt;https://github.com/tomchristie/django-rest-framework&lt;/a&gt;
&lt;a href="https://github.com/marcgibbons/django-rest-swagger"&gt;https://github.com/marcgibbons/django-rest-swagger&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 29 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-29:posts/2015/июля/29/django-rest-api/</guid><category>django</category><category>rest</category><category>api</category><category>swagger</category></item><item><title>Классы и функции</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/28/klassy-i-funktsii/</link><description>&lt;p&gt;До сих путаетесь между функциями, методами, классами и объектами? Пора разобраться в этом.
Данная статья расскажет, что такое Bound и UnBound методы, как можно в динамике добавлять поля в объект, как перегружать методы.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://0agr.ru/blog/2011/05/03/advanced-python-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B/"&gt;http://0agr.ru/blog/2011/05/03/advanced-python-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 28 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-28:posts/2015/июля/28/klassy-i-funktsii/</guid><category>интерпретатор</category></item><item><title>Имитация файловой системы с помощью mock</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/28/imitatsiia-failovoi-sistemy-s-pomoshchiu-mock/</link><description>&lt;p&gt;Вы пишите тесты? Тогда вам знаком модуль mock (в Python3 находится в unittest). Это модуль, который позволяет сделать имитацию объекта.&lt;/p&gt;
&lt;p&gt;Это необходимо, когда пишите тесты на свой код, а этот код использует множество долгих приготовлений: сходить в БД, разобрать данные еще что-то. Вот в этом случае вы можете провести имитацию всех этих долгих приготовлений и сконцентрироваться на написании тестов для своего кода.&lt;/p&gt;
&lt;p&gt;В случае с файловой системой немного сложней. Вот надо какие-то файлы создавать,в них что-то писать. Засорять свою домашнюю директорию папками "temp"? Не обязательно, можно имитировать файловую систему с помощью mockfs.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mockfs/mockfs"&gt;https://github.com/mockfs/mockfs&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 28 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-28:posts/2015/июля/28/imitatsiia-failovoi-sistemy-s-pomoshchiu-mock/</guid><category>тест</category><category>mock</category><category>test</category></item><item><title>Регулярные выражения</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/27/reguliarnye-vyrazheniia/</link><description>&lt;p&gt;Предположим, у нас есть задача - выдрать из крупного текстового файла (файла с логами) все IPv4 (адреса клиентов, например). Как это можно сделать?&lt;/p&gt;
&lt;p&gt;Хорошим инструментом для решения этой задачи являются регулярные выражения. Регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле.&lt;br /&gt;
Возможно, вы уже встречались с записями типа:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;lt;([a-z]+)[^&amp;gt;]*(?&amp;lt;!/)&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Большая вероятность, что это было регулярное выражение.
Регулярные выражения - это мощный инструмент, который стоит изучить и осознать. Не надо запоминать все конструкции, достаточно понять принцип.&lt;/p&gt;
&lt;p&gt;Для погружения в эту тему, рекомендуем эти материалы:
&lt;a href="http://tproger.ru/translations/regular-expression-python/"&gt;http://tproger.ru/translations/regular-expression-python/&lt;/a&gt;
&lt;a href="http://qntm.org/files/re/re.html"&gt;http://qntm.org/files/re/re.html&lt;/a&gt;
&lt;a href="http://habrahabr.ru/post/115825/"&gt;http://habrahabr.ru/post/115825/&lt;/a&gt;
&lt;a href="http://pep8.ru/doc/dive-into-python-3/7.html"&gt;http://pep8.ru/doc/dive-into-python-3/7.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 27 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-27:posts/2015/июля/27/reguliarnye-vyrazheniia/</guid><category>регулярные выражения</category><category>regex</category><category>regexp</category></item><item><title>Встроенные функции Python</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/27/vstroennye-funktsii-python/</link><description>&lt;p&gt;Стандартная библиотека Python отличается хорошей документацией и широким ассортиментом готовых решений.
Python предоставляет без малого 68 встроенных функций: это получение модуля числа, бинарное и hex представления числа, различные преобразование типов, сложение, возведение в степень и многие другие.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.5/library/functions.html"&gt;https://docs.python.org/3.5/library/functions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А вы знали, что в Python всё является объектом? Даже число&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;__abs__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__add__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__and__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;....&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;denominator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;imag&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;numerator&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;real&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 27 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-27:posts/2015/июля/27/vstroennye-funktsii-python/</guid><category>библиотека</category></item><item><title>PEP 471 (Python 3.5) добавил в модуль os новую функцию - scandir.</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/25/pep-471-python-35-dobavil-v-modul-os-novuiu-funktsiiu-scandir/</link><description>&lt;p&gt;PEP 471 (Python 3.5) добавил в модуль os новую функцию - scandir. &lt;/p&gt;
&lt;p&gt;Функция scandir возвращает генератор, который содержит директории по пути.
Польза scandir состоит в производительности. Теперь os.listdir и os.walk будут работать в 2-20 раз быстрее.&lt;/p&gt;
&lt;p&gt;Пример: функция, которая возвращает генератор с директориями начинающиеся с точки:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;subdirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Yield directory names not starting with &amp;#39;.&amp;#39; under given path.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scandir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_dir&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 25 Jul 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-25:posts/2015/июля/25/pep-471-python-35-dobavil-v-modul-os-novuiu-funktsiiu-scandir/</guid><category>pep</category><category>фича</category><category>scandir</category></item><item><title>Tkinter</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/25/tkinter/</link><description>&lt;p&gt;Родным модулем для построения GUI интерфейсов для Python программ является Tkinter.
Данная библиотека позволяет построить несложные интерфейсы. Tkinter есть на всех платформах где есть Python. В Python ветки 2.x.x при импорте модуля Tkinter, он пишется в большой буквы (иначе возникает ошибка). При импорте tkinter в версиях 3.x.x Питона имя модуля пишется с маленькой буквы.&lt;/p&gt;
&lt;p&gt;Данный курс - &lt;a href="http://younglinux.info/tkinter.php"&gt;http://younglinux.info/tkinter.php&lt;/a&gt; - "Создание GUI на Python с помощью библиотеки Tkinter" знакомит с особенностями разработки графического интерфейса пользователя на основе языка программирования Python(создание виджет и обработчиков событий, связывание с событиями и др.).&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 25 Jul 2015 18:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-25:posts/2015/июля/25/tkinter/</guid><category>GUI</category><category>интерфейс</category><category>tkinter</category></item><item><title>Интерпретатор brainfuck на Python</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/25/interpretator-brainfuck-na-python/</link><description>&lt;p&gt;Язык brainfuck для хранения данных использует ячейки (по-хорошему бесконечное число ячеек) и состоит всего из восьми команд, поэтому выучить его будет легко.
В этой статье показан интерпретатор brainfuck на Python
&lt;a href="http://pythonworld.ru/primery-programm/interpretator-brainfuck.html"&gt;http://pythonworld.ru/primery-programm/interpretator-brainfuck.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 25 Jul 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-25:posts/2015/июля/25/interpretator-brainfuck-na-python/</guid><category>интерпретатор</category></item><item><title>Набор GUI библиотек для Python</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/25/nabor-gui-bibliotek-dlia-python/</link><description>&lt;p&gt;На странице Python-wiki представлен огромный список пакетов для создания GUI на Python
&lt;a href="https://wiki.python.org/moin/GuiProgramming"&gt;https://wiki.python.org/moin/GuiProgramming&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Sat, 25 Jul 2015 10:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-25:posts/2015/июля/25/nabor-gui-bibliotek-dlia-python/</guid><category>GUI</category><category>интерфейс</category></item><item><title>Disqus - самое крупное django приложением в web.</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/24/disqus-samoe-krupnoe-django-prilozheniem-v-web/</link><description>&lt;p&gt;Disqus — веб-сервис, который предоставляет возможность добавить форму для интернет-обсуждений и комментариев на сайт пользователя использует Python. Сервис использует Python (Django).
По заверениям Disqus - они являются самым крупным django приложением в web.
&lt;a href="https://disqus.com/"&gt;https://disqus.com/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 24 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-24:posts/2015/июля/24/disqus-samoe-krupnoe-django-prilozheniem-v-web/</guid><category>проект</category></item><item><title>TIOBE за июль 2015: Python находится на 5-ом месте</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/24/tiobe-za-iiul-2015-python-nakhoditsia-na-5-om-meste/</link><description>&lt;p&gt;По рейтингу TIOBE за июль 2015 Python находится на 5-ом месте, год назад был на 8-ом.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html"&gt;http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Fri, 24 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-24:posts/2015/июля/24/tiobe-za-iiul-2015-python-nakhoditsia-na-5-om-meste/</guid><category>рейтинг</category></item><item><title>Интересно как работает Python?</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/23/interesno-kak-rabotaet-python/</link><description>&lt;p&gt;Интересно как работает Python?&lt;/p&gt;
&lt;p&gt;Рекомендуем изучить материалы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Интерпретатор Python: о чём думает змея? (часть I-III) - &lt;a href="http://habrahabr.ru/post/206420/"&gt;http://habrahabr.ru/post/206420/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python изнутри. Введение - &lt;a href="habrahabr.ru/company/buruki/blog/189972/"&gt;habrahabr.ru/company/buruki/blog/189972/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python изнутри. Объекты. Голова - &lt;a href="habrahabr.ru/company/buruki/blog/189986/"&gt;habrahabr.ru/company/buruki/blog/189986/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python изнутри. Объекты. Хвост - &lt;a href="habrahabr.ru/company/buruki/blog/190336/"&gt;habrahabr.ru/company/buruki/blog/190336/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python изнутри. Структуры процесса - &lt;a href="habrahabr.ru/company/buruki/blog/191032/"&gt;habrahabr.ru/company/buruki/blog/191032/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 23 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-23:posts/2015/июля/23/interesno-kak-rabotaet-python/</guid><category>python</category><category>интерпретатор</category><category>байт-код</category></item><item><title>Как работает Python?</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/23/kak-rabotaet-python/</link><description>&lt;p&gt;Как работает Python, что такое интерпретатор, как работает компилятор и что такое байт-код, далее расскажу о виртуальной машине (PVM) и о производительности Python. Также о альтернативных реализациях интерпретатора.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://adw0rd.com/2009/08/22/python-howto-work/"&gt;http://adw0rd.com/2009/08/22/python-howto-work/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Thu, 23 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-23:posts/2015/июля/23/kak-rabotaet-python/</guid><category>python</category><category>интерпретатор</category><category>байт-код</category></item><item><title>Django DB Mailer - батарейка для отправки email</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/22/django-db-mailer-batareika-dlia-otpravki-email/</link><description>&lt;p&gt;В подавляющем большинстве проектов используется отправка сообщений на почтовые адреса клиентов/админов/отделов. На сколько утомительно каждый раз создавать шаблоны на файловой системе, задавать сигналы, использовать часто дублирующийся код для рендеринга и отправки.&lt;/p&gt;
&lt;p&gt;В конечном итоге встают задачи о фоновой отправке, об изменениях отправителя, приоритизации, повторной отправке сообщения в случае неудачи, частом редактировании по просьбе клиента/маркетологов, прикреплению к письму стандартных файлов в виде каких-то инструкций по применению продукта, или же стандартных документов, отчетов по клиентам, переводам и тд и тп.&lt;/p&gt;
&lt;p&gt;В больших проектах часто необходимо визуально разделять шаблоны на категории, для фильтрации, дабы не тратить время на редактирование менее важных шаблонов при рефакторинге, и во избежание путаницы с новым контентом, или при работе со старым.&lt;/p&gt;
&lt;p&gt;Для подобных решений существует простая батарейка, призванная решить большинство подобных проблем, и избавить Вас от лишнего кода, сопровождения и нервотрепки.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://habrahabr.ru/post/253445/"&gt;http://habrahabr.ru/post/253445/&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 22 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-22:posts/2015/июля/22/django-db-mailer-batareika-dlia-otpravki-email/</guid><category>django</category><category>mail</category><category>email</category></item><item><title>requests</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/22/requests/</link><description>&lt;p&gt;requests - &lt;a href="http://docs.python-requests.org/en/latest/"&gt;http://docs.python-requests.org/en/latest/&lt;/a&gt; - универсальный (для python2, python3) модуль для создание HTTP запросов.
Данный модуль позволяет очень просто послать запрос, получить данные.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;https://api.github.com/user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;pass&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;
&lt;span class="mi"&gt;200&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;content-type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;application/json; charset=utf8&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
&lt;span class="s"&gt;u&amp;#39;{&amp;quot;type&amp;quot;:&amp;quot;User&amp;quot;...&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;private_gists&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;419&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;total_private_repos&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;77&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Wed, 22 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-22:posts/2015/июля/22/requests/</guid><category>requests</category><category>http</category></item><item><title>Тесты тесты тесты: unittest - основной инструмент тестирования</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/21/testy-testy-testy-unittest-osnovnoi-instrument-testirovaniia/</link><description>&lt;p&gt;Одним из основных инструментов для тестирования в Python - unittest&lt;/p&gt;
&lt;p&gt;Это стандартный модуль для реализации юнит-тестов на Python.
Unittest это порт JUnit с Java, иными словами ООП стиль, что весьма удобно для тестирования и процедур, и классов.&lt;/p&gt;
&lt;p&gt;Возможностей в данном модуле довольно много: проверки (&lt;code&gt;assert*&lt;/code&gt;), декораторы, позволяющие пропустить отдельный тест (&lt;code&gt;@skip&lt;/code&gt;, &lt;code&gt;@skipIf&lt;/code&gt;) или обозначить сломанные тесты (&lt;code&gt;@expectedFailure&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;При написании тестов надо исходит из следующих принципов:&lt;/p&gt;
&lt;p&gt;Работа теста не должна зависеть от результатов работы других тестов.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Тест должен использовать данные, специально для него подготовленные, и никакие другие.&lt;/li&gt;
&lt;li&gt;Тест не должен требовать ввода от пользователя&lt;/li&gt;
&lt;li&gt;Тесты не должны перекрывать друг друга (не надо писать одинаковые тесты 20 раз). Можно писать частично перекрывающие тесты.&lt;/li&gt;
&lt;li&gt;Нашли баг -&amp;gt; напиши тест&lt;/li&gt;
&lt;li&gt;Тесты надо поддерживать в рабочем состоянии&lt;/li&gt;
&lt;li&gt;Модульные тесты не должны проверять производительность сущности (класса, функции)&lt;/li&gt;
&lt;li&gt;Тесты должны проверять не только то, что сущность работает корректно на корректных данных, но и то что ведет себя адекватно при некорректных данных.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 21 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-21:posts/2015/июля/21/testy-testy-testy-unittest-osnovnoi-instrument-testirovaniia/</guid><category>тесты</category><category>test</category><category>unittest</category></item><item><title>unittest</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/21/unittest/</link><description>&lt;p&gt;unittest - https://docs.python.org/3.5/library/unittest.html - фреймворк для написания юнит-тестов.
unittest является частью стандартной поставки.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Tue, 21 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-21:posts/2015/июля/21/unittest/</guid><category>тесты</category><category>test</category><category>unittest</category></item><item><title>Генераторы списков</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/20/generatory-spiskov/</link><description>&lt;p&gt;Если вы использовали Python достаточно долго, вы должны были хотя бы слышать о понятии «list comprehensions». Это способ уместить цикл for, блок if и присваивание в одну строку.&lt;/p&gt;
&lt;p&gt;Генератор списков - яркий пример «синтаксического сахара». То есть конструкции, без которой легко можно обойтись, но с ней намного лучше :) Генераторы списков, как это не странно, предназначены для удобной обработки списков, к которой можно отнести и создание новых списков, и модификацию существующих.
Допустим, нам необходимо получить список нечетных чисел, не превышающих 25.
В принципе, только познакомившись с работой команды xrange решить эту проблему несложно.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В общем-то, полученный результат — целиком нас устраивает всем, кроме длинной записи. тут-то на помощь и придет наш «сахарок». В самом простом виде, он обычно &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В общем виде эта конструкция такова:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python
[stmt for var in iterable if predicate]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;По-мимо генератора списка есть синтаксический сахар - генератор словарей.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 20 Jul 2015 17:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-20:posts/2015/июля/20/generatory-spiskov/</guid><category>синтаксис</category><category>syntax</category><category>list</category></item><item><title>Почему Python клёвый?</title><link>http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/20/pochemu-python-kliovyi/</link><description>&lt;p&gt;Видео с конференции PyCon
В видео докладчик рассказал о плюсах Python. О тех самых преимуществах, которые не надо обходить стороной.
&lt;a class='embedly-card' data-card-chrome='0' href='http://www.youtube.com/watch?v=GyP59P8h7uQ'&gt;&lt;/a&gt;
            &lt;script&gt;
            !function(a){
                var b="embedly-platform",c="script";
                if(!a.getElementById(b)){
                    var d=a.createElement(c);
                    d.id=b;
                    d.src=("https:"===document.location.protocol?"https":"http")+"://cdn.embedly.com/widgets/platform.js";
                    var e=document.getElementsByTagName(c)[0];e.parentNode.insertBefore(d,e)}
                }(document);
            &lt;/script&gt;
            &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Sapronov</dc:creator><pubDate>Mon, 20 Jul 2015 08:00:00 +0600</pubDate><guid>tag:pynsk.ru,2015-07-20:posts/2015/июля/20/pochemu-python-kliovyi/</guid><category>видео</category><category>pycon</category></item></channel></rss>