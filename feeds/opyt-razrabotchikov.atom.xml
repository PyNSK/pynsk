<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyNSK - Новосибирское Python сообщество</title><link href="http://pynsk.ru/" rel="alternate"></link><link href="http://pynsk.ru/feeds/opyt-razrabotchikov.atom.xml" rel="self"></link><id>http://pynsk.ru/</id><updated>2015-10-08T10:00:00+06:00</updated><entry><title>Опыт разработчиков: замыкания (closure). Зачем и почему.</title><link href="http://pynsk.ru/posts/2015/%D0%BE%D0%BA%D1%82./08/opyt-razrabotchikov-zamykaniia-closure-zachem-i-pochemu/" rel="alternate"></link><updated>2015-10-08T10:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-10-08:posts/2015/окт./08/opyt-razrabotchikov-zamykaniia-closure-zachem-i-pochemu/</id><summary type="html">&lt;p&gt;В синтаксисе Python один и тот же символ или конструкция часто используется для разных целей
Возможно вы встречались с подобным кодом:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;outer_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inner_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# inner_func замкнуло в себе х&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inner_func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Похож на декоратор. Это называется замыканием. Это более общий случай декоратора.
Смысл замыкания состоит в том, что определение функции "замораживает" окружающий её контекст на момент определения. Это может делаться различными способами, например, за счёт параметризации создания функции&lt;/p&gt;
&lt;p&gt;Такой подход позволяет:
Устранить жестко кодированные константы
Убрать глобальные переменные из кода
Увеличить производительность
Если первые два пункта весьма понятны, то третий поясню. В Python загрузка переменных в SCOPE (локальную область) долгий процесс (сравнительно), поэтому чем реже это делается - тем быстрее код. 
Пример: функция, которая делает insert в базу данных. Можно объявить коннект в замыкании и использовать.&lt;/p&gt;
&lt;p&gt;Есть один нюанс. В Питоне замкнутые переменные доступны только для чтения. Чтобы обойти такое ограничение, нужно замыкать переменные контейнерного типа: списки, кортежи и т.д.. Сами замкнутые переменные нельзя будет перезаписывать, а вот содержимое контейнера - пожалуйста.&lt;/p&gt;
&lt;p&gt;Замкнемся на ссылки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.jetfix.ru/post/zamykaniya-v-python-chto-eto-i-s-chem-ih-edyat"&gt;http://blog.jetfix.ru/post/zamykaniya-v-python-chto-eto-i-s-chem-ih-edyat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/ru/library/l-python_details_03/"&gt;https://www.ibm.com/developerworks/ru/library/l-python_details_03/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="замыкание"></category><category term="closure"></category></entry><entry><title>Опыт разработчиков: основы декларативной магии</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./25/opyt-razrabotchikov-osnovy-deklarativnoi-magii/" rel="alternate"></link><updated>2015-09-25T18:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-25:posts/2015/сент./25/opyt-razrabotchikov-osnovy-deklarativnoi-magii/</id><summary type="html">&lt;p&gt;&lt;img alt="embed" src="http://www.youtube.com/watch?v=luhyEER7_KM" /&gt;&lt;/p&gt;</summary><category term="опыт"></category><category term="видео"></category><category term="декларативный язык"></category><category term="магия"></category></entry><entry><title>Опыт разработчиков: соглашения о кодировании</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./25/opyt-razrabotchikov-soglasheniia-o-kodirovanii/" rel="alternate"></link><updated>2015-09-25T10:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-25:posts/2015/сент./25/opyt-razrabotchikov-soglasheniia-o-kodirovanii/</id><summary type="html">&lt;p&gt;В обществе существуют различные соглашения. Соглашения рождаются не просто так, а для того чтобы о чем-то условится и начать создавать.&lt;/p&gt;
&lt;p&gt;Для разработчика важным является соглашение о кодировании. Это своего рода свод "законов", которые принимает новый разработчик, когда погружается в проект. Чаще всего такие законы очевидны и естественны.&lt;/p&gt;
&lt;p&gt;Возьмем пример - длина строки не более 79 символов. В свое время дисплеи содержали лишь 80 столбцов, поэтому было удобно, когда код помещался на экран.
Подобные рекомендации или "законы" присущи любому популярному языку. Приглашаю с ними ознакомится по ссылке  &lt;a href="https://github.com/SalGnt/cscs"&gt;https://github.com/SalGnt/cscs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. PEP8&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image" src="http://i.imgur.com/66ON9pI.png" /&gt;&lt;/p&gt;</summary></entry><entry><title>Опыт разработчиков: Работа с ошибками. Как ловить исключения и что потом с ними делать</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./15/opyt-razrabotchikov-rabota-s-oshibkami-kak-lovit-iskliucheniia-i-chto-potom-s-nimi-delat/" rel="alternate"></link><updated>2015-09-15T18:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-15:posts/2015/сент./15/opyt-razrabotchikov-rabota-s-oshibkami-kak-lovit-iskliucheniia-i-chto-potom-s-nimi-delat/</id><summary type="html">&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/hzVECcMI8ys?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="исключение"></category><category term="ошибка"></category><category term="видео"></category><category term="опыт"></category></entry><entry><title>Опыт разработчиков: assert как средство для валидации</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./15/opyt-razrabotchikov-assert-kak-sredstvo-dlia-validatsii/" rel="alternate"></link><updated>2015-09-15T10:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-15:posts/2015/сент./15/opyt-razrabotchikov-assert-kak-sredstvo-dlia-validatsii/</id><summary type="html">&lt;p&gt;Опыт разработчиков: assert как средство для валидации&lt;/p&gt;
&lt;p&gt;Хочется сегодня осветить такой элемент синтаксиса как assert. 
assert - это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.&lt;/p&gt;
&lt;p&gt;Какая же польза от этой проверки?
Представим что мы что-то пишем код, который получает данные из Базы Данных, производит обработку данных и загружает результат обратно. По замыслу этого кода мы должны положить в базу столько же данных сколько и получили. 
Но так как мы написали код с ошибками (случайно), то количество данных не совпадает. И что же случится?&lt;/p&gt;
&lt;p&gt;В этом случае очень хорошо себя показывает assert. Эта конструкция проверят данные и в случае не соответствия ожиданиям - бросает AssertException.&lt;/p&gt;
&lt;p&gt;Примеры кода:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;command&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Not found command&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;command&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Not valid command&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="assert"></category><category term="тест"></category></entry><entry><title>Опыт разработчиков: файл requirements.txt в каждый проект</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./04/opyt-razrabotchikov-fail-requirementstxt-v-kazhdyi-proekt/" rel="alternate"></link><updated>2015-09-04T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-04:posts/2015/сент./04/opyt-razrabotchikov-fail-requirementstxt-v-kazhdyi-proekt/</id><summary type="html">&lt;p&gt;Первой проблемой при поддержке старых проектов является понять, как запустить его. 
Чтобы немного упростить эту задачу разработчики используют pip и файл requirements.txt. В этом файле записываются все необходимые для работы библиотеки и, что самое главное, указывают версии этих библиотек. &lt;/p&gt;
&lt;p&gt;Имея такой файл настройка окружения для старта проекта может состоять из одной команды:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;</summary><category term="pip"></category><category term="requirements.txt"></category><category term="requirements"></category></entry><entry><title>Опыт разработчиков: пишем совместимый код (Python 2 и 3)</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./25/opyt-razrabotchikov-pishem-sovmestimyi-kod-python-2-i-3/" rel="alternate"></link><updated>2015-08-25T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-25:posts/2015/авг./25/opyt-razrabotchikov-pishem-sovmestimyi-kod-python-2-i-3/</id><summary type="html">&lt;p&gt;Python 3 вышел в 2008 году, однако, до сих пор не все перешли на новую версию. Раньше основными аргументами, чтобы не начинать новые проекты на Python были - библиотеки не готовы к использованию, нет особых фич.&lt;/p&gt;
&lt;p&gt;Первое уже вполне решено - &lt;a href="https://python3wos.appspot.com/"&gt;https://python3wos.appspot.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;А второе, начиная с Python 3.3 уже слабо актуально - много новых фич введено.&lt;/p&gt;
&lt;p&gt;Поэтому теперь актуально писать совместимый код. Для наиболее легкого написания кода одинаково работающего как в Python 2.6+ так и в Python 3.* рекомендуется использовать библиотеку six.&lt;/p&gt;
&lt;p&gt;В ней собрано большее количество инструментов позволяющих писать кросверсионный код для Python 2.x-3.x. Для нахождения мест подлежащих изменению рекомендуется воспользоваться утилитами 2to3 или python-modernize.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pythonhosted.org/six/"&gt;https://pythonhosted.org/six/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.python.org/2.7/library/2to3.html"&gt;http://docs.python.org/2.7/library/2to3.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mitsuhiko/python-modernize"&gt;https://github.com/mitsuhiko/python-modernize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python2"></category><category term="python3"></category></entry><entry><title>Опыт разработчиков: "Перестаньте писать классы"</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./13/opyt-razrabotchikov-perestante-pisat-klassy/" rel="alternate"></link><updated>2015-08-13T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-13:posts/2015/авг./13/opyt-razrabotchikov-perestante-pisat-klassy/</id><summary type="html">&lt;p&gt;Признак того, что объект не должен быть классом — если в нём всего 2 метода, и один из них — инициализация, &lt;code&gt;__init__&lt;/code&gt;. Каждый раз видя это, подумайте: «наверное, мне нужна просто одна функция».&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/140581/"&gt;http://habrahabr.ru/post/140581/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/143620/"&gt;http://habrahabr.ru/post/143620/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry></feed>