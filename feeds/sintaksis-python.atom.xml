<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyNSK - Новосибирское Python сообщество</title><link href="http://pynsk.ru/" rel="alternate"></link><link href="http://pynsk.ru/feeds/sintaksis-python.atom.xml" rel="self"></link><id>http://pynsk.ru/</id><updated>2015-09-24T10:00:00+06:00</updated><entry><title>Синтаксис Python: dir()</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./24/sintaksis-python-dir/" rel="alternate"></link><updated>2015-09-24T10:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-24:posts/2015/сент./24/sintaksis-python-dir/</id><summary type="html">&lt;p&gt;Достался нам в наследство какой-то код. А там непонятный объект с названием &lt;code&gt;super_object_1&lt;/code&gt;. 
Как понять что это за объект?&lt;/p&gt;
&lt;p&gt;На помощь приходят встроенные функции - &lt;code&gt;type()&lt;/code&gt;, &lt;code&gt;dir()&lt;/code&gt;. Если с &lt;code&gt;type()&lt;/code&gt; все ясно - возвращает тип, то с &lt;code&gt;dir&lt;/code&gt; не совсем. &lt;/p&gt;
&lt;p&gt;dir - Возвращает имена переменных, доступные в локальной области, либо атрибуты указанного объекта в алфавитном порядке.
Это значит, что при вызове кода:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;super_object_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# мы получим список его методов.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Но есть тонкости:
Определение в классе метода &lt;code&gt;__dir__()&lt;/code&gt;, возвращающего список и имён, позволяет варьировать результат выполнения &lt;code&gt;dir()&lt;/code&gt; для экземпляров класса. 
Для объектов, класс которых не определил &lt;code&gt;__dir__()&lt;/code&gt;, функция попытается определить атрибуты по данным &lt;code&gt;__dict__&lt;/code&gt;.
Возвращаемый список может включать не все атрибуты, особенно в случаях с переопределенным &lt;code&gt;__getattr__()&lt;/code&gt;.&lt;/p&gt;</summary></entry><entry><title>Синтаксис Python: encode/decode</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./21/sintaksis-python-encodedecode/" rel="alternate"></link><updated>2015-09-21T10:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-21:posts/2015/сент./21/sintaksis-python-encodedecode/</id><summary type="html">&lt;p&gt;Вероятно, самым заметным отличием Python 2 от Python 3 является юникод.  Это нововведение упростило работу со строками. Однако, так как Python 2 еще в строю, то кодировки еще в силе и не мало разработчиков путается между encode и decode.&lt;/p&gt;
&lt;p&gt;Стоит привести картинку, которая прояснит все:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image" src="http://eli.thegreenplace.net/images/2012/01/py3_string_bytes.png" /&gt;&lt;/p&gt;
&lt;p&gt;Таким образом, если у нас есть строка:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Cool page&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;То существует множество способов (кодировок) представить ее в байтовом виде&lt;/p&gt;
&lt;p&gt;Поэтому мы и пишем:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;название кодировки&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# переводим строку байтовый вид&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;И обратно. Если у нас есть набор байт, то чтобы получить строку пишем:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;байт-строка&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;lt;название кодировки&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# получаем из байтовой строки настоящую строку&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Подробнее:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/135913/"&gt;http://habrahabr.ru/post/135913/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3/"&gt;http://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="encode"></category><category term="decode"></category><category term="синтаксис"></category></entry><entry><title>Синтаксис Python: работа с матрицами</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./14/sintaksis-python-rabota-s-matritsami/" rel="alternate"></link><updated>2015-09-14T18:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-14:posts/2015/сент./14/sintaksis-python-rabota-s-matritsami/</id><summary type="html">&lt;p&gt;Матрица - это, если утрировать, "табличка", N-мерный массив (чаще всего двумерный). 
Матрицы возникают не редко. Например, игровое поле, карта мира - тоже можно представить матрицей, да то же решето Эратосфена - тоже двумерный массив, или вообще - вложенные списки.&lt;/p&gt;
&lt;p&gt;Это все создает необходимость знать как работать с матрицами и какими инструментами. Модулей для работы с этими объектами не мало, самые известные - стандартный math и numpy.&lt;/p&gt;
&lt;p&gt;В Python 3.5 появился новый оператор - @
Этот оператор позволяет перемножать матрицы:&lt;/p&gt;
&lt;p&gt;a @ b&lt;/p&gt;
&lt;p&gt;Подробно о операторе:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0465/"&gt;https://www.python.org/dev/peps/pep-0465/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="матрица"></category><category term="синтаксис"></category></entry><entry><title>Синтаксис Python: super() это супер</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./11/sintaksis-python-super-eto-super/" rel="alternate"></link><updated>2015-09-11T18:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-11:posts/2015/сент./11/sintaksis-python-super-eto-super/</id><summary type="html">&lt;p&gt;Вы знаете что такое super()?
Думаете что это вызов метода класса родителя? Если так, то вам стоит посмотреть это видео.
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/61UuKJRl2m0?feature=oembed" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="super"></category><category term="видео"></category></entry><entry><title>Синтаксис Python: генераторы</title><link href="http://pynsk.ru/posts/2015/%D1%81%D0%B5%D0%BD%D1%82./07/sintaksis-python-generatory/" rel="alternate"></link><updated>2015-09-07T18:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-09-07:posts/2015/сент./07/sintaksis-python-generatory/</id><summary type="html">&lt;p&gt;Генераторы это итерируемые объекты, которые можно прочитать лишь один раз. Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; mygenerator = (x*x for x in range(3))
&amp;gt;&amp;gt;&amp;gt; for i in mygenerator :
...    print(i)
0
1
4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Казалось бы, всего один раз можно пройти по данным. Зачем это?&lt;/p&gt;
&lt;p&gt;На практике мы редко проходим по одним и тем же данным несколько раз. 
При этом нам не всегда нужны все данные. Например, стоит задача проверить что все элементы массива положительные. Вот мы пишем цикл, в котором сравниваем элементы с нулем. И бац, попадается отрицательный элемент. Можем уже дальше не проверять и уже кинуть ошибку. При этом весь массив не находится в памяти. &lt;/p&gt;
&lt;p&gt;Это если обычные числа, а если элементы коллекции это результаты вычисления функции - вот как в коде выше, это квадраты. А элементов у нас не 3, а 1 миллион. А в данный момент нам нужны только первые 500, по ним определим нужны ли нам остальные. Вот здесь и приходят на помощь генераторы - они возвращают именно столько сколько и надо данных.&lt;/p&gt;</summary><category term="генератор"></category><category term="yield"></category></entry><entry><title>Синтаксис Python: множества (set)</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./31/sintaksis-python-mnozhestva-set/" rel="alternate"></link><updated>2015-08-31T17:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-31:posts/2015/авг./31/sintaksis-python-mnozhestva-set/</id><summary type="html">&lt;p&gt;Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt; &lt;span class="c"&gt;# генератор множеств&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;81&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;  &lt;span class="c"&gt;# А так нельзя!&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nc"&gt;dict&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html"&gt;http://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://server.179.ru/tasks/python/2014b1/17-sets.html"&gt;http://server.179.ru/tasks/python/2014b1/17-sets.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://informatics.mccme.ru/mod/book/view.php?id=6693"&gt;http://informatics.mccme.ru/mod/book/view.php?id=6693&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="set"></category></entry><entry><title>Синтаксис Python: оператор yield</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./31/sintaksis-python-operator-yield/" rel="alternate"></link><updated>2015-08-31T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-31:posts/2015/авг./31/sintaksis-python-operator-yield/</id><summary type="html">&lt;p&gt;При чтении чужого кода можно столкнутся с многими непонятными конструкциями. А сейчас хочу коротко осветить такую конструкцию как yield.
Yield - это ключевое слово которое используется так же, как и слово return. Разница в том, что функция при этом начинает возвращать генератор вместо значения.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x2e58870&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В данном случае, с практической точки зрения, это бесполезный пример. Ощутимую пользу вы получите в ситуации, когда ваша функция должна будет возвращать достаточно большой объём данных, но использовать их надо будет только один раз.
Для того чтобы до конца освоить оператор yield, вы должны знать, что когда вы вызываете функцию, в теле которой находится yield, выполнение этой функции не происходит. Вместо выполнения, функция вернёт объект-генератор. Выглядит это несколько странно на первый взгляд - функция вызвана, но код не выполнен, но, просто запомните этот факт. Код будет выполнятся при каждой итерации - будь то цикл "for &amp;lt;...&amp;gt; in &lt;generator&gt;" или вызов метода &lt;generator&gt;.next().&lt;/p&gt;
&lt;p&gt;Ссылки по теме:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://zetblog.ru/programming/201304/python-iterators-generators-yield/"&gt;http://zetblog.ru/programming/201304/python-iterators-generators-yield/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://habrahabr.ru/post/132554/"&gt;http://habrahabr.ru/post/132554/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/ru/library/l-pycon/"&gt;http://www.ibm.com/developerworks/ru/library/l-pycon/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.jetfix.ru/post/chto-takoe-yield-i-dlya-chego-eto-slovo-nuzhno"&gt;http://blog.jetfix.ru/post/chto-takoe-yield-i-dlya-chego-eto-slovo-nuzhno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="yield"></category><category term="синтаксис"></category></entry><entry><title>Синтаксис Python: with ... as</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./24/sintaksis-python-with-as/" rel="alternate"></link><updated>2015-08-24T17:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-24:posts/2015/авг./24/sintaksis-python-with-as/</id><summary type="html">&lt;p&gt;Конструкция &lt;code&gt;with ... as&lt;/code&gt; используется для оборачивания выполнения блока инструкций менеджером контекста. Иногда это более удобная конструкция, чем &lt;code&gt;try...except...finally&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Синтаксис конструкции &lt;code&gt;with ... as&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;with&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;as&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;as&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;suite&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Теперь по порядку о том, что происходит при выполнении данного блока:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Выполняется выражение в конструкции &lt;code&gt;with ... as&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Загружается специальный метод &lt;code&gt;__exit__&lt;/code&gt; для дальнейшего использования.&lt;/li&gt;
&lt;li&gt;Выполняется метод &lt;code&gt;__enter__&lt;/code&gt;. Если конструкция &lt;code&gt;with&lt;/code&gt; включает в себя слово &lt;code&gt;as&lt;/code&gt;, то возвращаемое методом &lt;code&gt;__enter__&lt;/code&gt; значение записывается в переменную.&lt;/li&gt;
&lt;li&gt;Выполняется suite.&lt;/li&gt;
&lt;li&gt;Вызывается метод &lt;code&gt;__exit__&lt;/code&gt;, причём неважно, выполнилось ли suite или произошло исключение. В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение None, если исключения не было.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Примером использования данной конструкции является чтение и запись из/в файл (гарантированное закрытие файла)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://effbot.org/zone/python-with-statement.htm"&gt;http://effbot.org/zone/python-with-statement.htm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html"&gt;http://pythonworld.ru/osnovy/with-as-menedzhery-konteksta.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/2/reference/compound_stmts.html"&gt;https://docs.python.org/2/reference/compound_stmts.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="синтаксис"></category><category term="with"></category></entry><entry><title>Синтаксис Python: знакомимся с синтаксисом за Y минут</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./24/sintaksis-python-znakomimsia-s-sintaksisom-za-y-minut/" rel="alternate"></link><updated>2015-08-24T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-24:posts/2015/авг./24/sintaksis-python-znakomimsia-s-sintaksisom-za-y-minut/</id><summary type="html">&lt;p&gt;Когда мне необходимо быстро вникнуть в синтаксис языка X, то использую этот сайт:
&lt;a href="http://learnxinyminutes.com/docs/ru-ru/python3-ru/"&gt;http://learnxinyminutes.com/docs/ru-ru/python3-ru/&lt;/a&gt;
А по ссылке вы найдете синтаксис языка Python&lt;/p&gt;</summary><category term="синтаксис"></category></entry><entry><title>Синтаксис Python: изменяемые и неизменяемые типы данных</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./17/sintaksis-python-izmeniaemye-i-neizmeniaemye-tipy-dannykh/" rel="alternate"></link><updated>2015-08-17T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-17:posts/2015/авг./17/sintaksis-python-izmeniaemye-i-neizmeniaemye-tipy-dannykh/</id><summary type="html">&lt;p&gt;Все типы данных в Python относятся к одной из 2-х категорий: изменяемые (mutable) и неизменяемые (unmutable). Многие из предопределённых типов данных Python — это типы неизменяемых объектов: числовые данные (int, float, complex), символьные строки (class 'str'), кортежи (tuple). Другие типы определены как изменяемые: списки (list), множества (set), словари (dict). Вновь определяемые пользователем типы (классы) могут быть определены как неизменяемые или изменяемые. Изменяемость объектов определённого типа является принципиально важной характеристикой, определяющей, может ли объект такого типа выступать в качестве ключа для словарей (dict) или нет.&lt;/p&gt;
&lt;p&gt;Подробнее по ссылке - &lt;a href="https://www.ibm.com/developerworks/ru/library/l-python_details_02/"&gt;https://www.ibm.com/developerworks/ru/library/l-python_details_02/&lt;/a&gt;&lt;/p&gt;</summary><category term="типы данных"></category></entry><entry><title>Синтаксис Python: конструкция switch</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./03/sintaksis-python-konstruktsiia-switch/" rel="alternate"></link><updated>2015-08-03T17:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-03:posts/2015/авг./03/sintaksis-python-konstruktsiia-switch/</id><summary type="html">&lt;p&gt;Стоит упомянуть про конструкцию switch в Python. Такой конструкции в языке нет, однако, выкрутится можно. Часто рекомендуют писать множественные elif'ы, но можно сделать так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;switch_case&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You entered &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;an out of range number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Input a number between 1 and 3: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;switch_case&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В этом примере мы создаем словарь, а затем получаем значение по нужному нам ключу.&lt;/p&gt;
&lt;p&gt;Вот только этот подход не работает, когда значение switch'а вычисляется в динамике. (Например, если мы приветствуем/прощаемся какого-то пользователя). &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В этом случае мы все также создаем словарь, но в качестве значений словаря прописываем функцию (в примере - lamdba функции). Затем получаем эту функцию словаря и вычисляем с аргументом.&lt;/p&gt;
&lt;p&gt;Еще способы реализации switch-case в Python:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/410695/"&gt;Recipe 410692: Readable switch construction without lambdas or dictionaries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/410695/"&gt;Recipe 410695: Exception-based Switch-Case&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.activestate.com/recipes/181064/"&gt;Recipe 181064: Using a Dictionary in place of a ’switch’ statement&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>Синтаксис Python: трехместное выражение if/else</title><link href="http://pynsk.ru/posts/2015/%D0%B0%D0%B2%D0%B3./03/sintaksis-python-trekhmestnoe-vyrazhenie-ifelse/" rel="alternate"></link><updated>2015-08-03T08:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-08-03:posts/2015/авг./03/sintaksis-python-trekhmestnoe-vyrazhenie-ifelse/</id><summary type="html">&lt;p&gt;Сегодня хочется упомянуть о непонятной на первый взгляд конструкции - тернарная условная операция, или по-русски - трехместное выражение &lt;code&gt;if/else&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Представим, есть такой код:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение &lt;code&gt;if/else&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;t&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;spam&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;t&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Синтаксис конструкции if-elif-else описан по ссылкам&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/tutorial/controlflow.html"&gt;https://docs.python.org/3/tutorial/controlflow.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonworld.ru/osnovy/instrukciya-if-elif-else-proverka-istinnosti-trexmestnoe-vyrazhenie-ifelse.html"&gt;http://pythonworld.ru/osnovy/instrukciya-if-elif-else-proverka-istinnosti-trexmestnoe-vyrazhenie-ifelse.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="if"></category><category term="синтаксис"></category></entry><entry><title>Классы и функции</title><link href="http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/28/klassy-i-funktsii/" rel="alternate"></link><updated>2015-07-28T17:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-07-28:posts/2015/июля/28/klassy-i-funktsii/</id><summary type="html">&lt;p&gt;До сих путаетесь между функциями, методами, классами и объектами? Пора разобраться в этом.
Данная статья расскажет, что такое Bound и UnBound методы, как можно в динамике добавлять поля в объект, как перегружать методы.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://0agr.ru/blog/2011/05/03/advanced-python-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B/"&gt;http://0agr.ru/blog/2011/05/03/advanced-python-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B/&lt;/a&gt;&lt;/p&gt;</summary><category term="интерпретатор"></category></entry><entry><title>Генераторы списков</title><link href="http://pynsk.ru/posts/2015/%D0%B8%D1%8E%D0%BB%D1%8F/20/generatory-spiskov/" rel="alternate"></link><updated>2015-07-20T17:00:00+06:00</updated><author><name>Alexander Sapronov</name></author><id>tag:pynsk.ru,2015-07-20:posts/2015/июля/20/generatory-spiskov/</id><summary type="html">&lt;p&gt;Если вы использовали Python достаточно долго, вы должны были хотя бы слышать о понятии «list comprehensions». Это способ уместить цикл for, блок if и присваивание в одну строку.&lt;/p&gt;
&lt;p&gt;Генератор списков - яркий пример «синтаксического сахара». То есть конструкции, без которой легко можно обойтись, но с ней намного лучше :) Генераторы списков, как это не странно, предназначены для удобной обработки списков, к которой можно отнести и создание новых списков, и модификацию существующих.
Допустим, нам необходимо получить список нечетных чисел, не превышающих 25.
В принципе, только познакомившись с работой команды xrange решить эту проблему несложно.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В общем-то, полученный результат — целиком нас устраивает всем, кроме длинной записи. тут-то на помощь и придет наш «сахарок». В самом простом виде, он обычно &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В общем виде эта конструкция такова:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python
[stmt for var in iterable if predicate]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;По-мимо генератора списка есть синтаксический сахар - генератор словарей.&lt;/p&gt;</summary><category term="синтаксис"></category><category term="syntax"></category><category term="list"></category></entry></feed>